{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"2970520119369190271","abi":{"parameters":[{"name":"move_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"init_grid","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"move_array","type":{"kind":"array","length":64,"type":{"kind":"struct","path":"Position","fields":[{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}}]}},"visibility":"private"}],"return_type":null,"error_types":{"2056779005453440704":{"error_kind":"string","string":"init_grid must be a permutation of 0..15"},"2763232959425933230":{"error_kind":"string","string":"Attempted to write past end of BoundedVec"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3585749724882332783":{"error_kind":"string","string":"move_count exceeds maximum allowed moves"},"4881232171340953631":{"error_kind":"string","string":"Move sequence isn't winning"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14762772751442043855":{"error_kind":"string","string":"Invalid move"},"15544221083219072719":{"error_kind":"string","string":"check_shuffle, lhs and rhs arrays do not contain equivalent values"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17679955115386040593":{"error_kind":"string","string":"Array has not been sorted correctly according to `ordering`."},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tb3bjnTbcZz7LrzmxTjlSa8iGIIsywYBQjJkycCGoXffPXNkRgwbWAvUT+iG/a2/2SO6q7oqsyNj5vw/f/hv//hf/+1//N2f/um///P/+sPf/O3/+cN//Zc//fnPf/off/fnf/6Hv//XP/3zP/386//5w/j+R3/+d/7xDzrvh3U/7D/8zfr5cO4HuR/0D39zfj7Y/eD3Q+QHG/fDvB/W/bDvh3M/yP1wT7F7it1T7J7i9xS/p/g9xe8pfk/xe4rfU/ye4vcUv6fEPSV+/lH++Ic5Zn1c9XHXx1MfpT7+HKnfx7gf56iPsz6u+rjr48/X2/dR6qPWR6uPXh/jflyjPs76uOrjro913qrzVp236rz1c55/H+N+3KM+zvr4c158H3/Om+ODnwPm+sAavOHnjLl/4HzP9/ngR3V+D8PRBmvwhiiQ73fmewxkNqyG3XAavpO/H0C0wRq+k7/vXaIgfxsTZsNq2A2n4Tv5+5G/38wL1uANUfD9hl6YDavhO3l+cBqkQRus4efk9T283+9swvdbe2E2/Jy8vv/z97t74TRIgzZYgzdEwfebfGE29Mnxnfw9laEN1uAN3zk/z/Iao2E2rIb6bVnfy+GCNGiDNXhDFHwvkguzYTX0yd8L4vsdW98r4kIUfK+JC/P+Qq7vVXFhN5wGafh+5Pwqa/CG70f++dVa36th+Qe74PtVX/rB9xTIB9pgDd4QBd+v+ooPZsNq+Dl5fz/g96t+QRp+Tt7zA2vwhij4ftUvzIbV8J28PjgN0qAN1uANUfD9ql+Y9wW78lc9YTecBmmo1/v6fmn3v//8/nzl4fvt3Pu+xebHuB+/X838OOvjqo+7Pp76KPVR62OdF3Ve1HlzjIbZsBp2w2mQBm2wBm/ok2efPPvk2SfPPnn2ybNPnn3y7JNnnzz75NUnrz559cnfb+Q+9fa8pd6X77+cBmn4/s/fe+X5/s9W78v5VWc3nAbr/zO+Kgq+X9bt9b58YTV850S9L1+Qhq+WjnoXPrPehS/Mhq8Wr3oXvnAavop86j337HrPTciuQOo998Jq2A2nQRq0wRq8Ierx+d5zL/Qj9r3nXtgNp0EatMEb8sCfX/b1/bJ/D8n5eSDzEfk+Wn30+zF/eKtOyKsV8uqFvJqhqP4nquWJanbi339kuv/6u3/9l3/8x0/yach+2rT/+ff/8o//9K9/+Jt/+rc///mPf/jff//nf8v/0//6n3//T/nxX//+X34++/Nc/eM//befjz8H/vc//fkfP/r3P/Krx29/6c9vqtVX/zQePED+4gOOnz7guOCA85cfINEHyIjfOGD/Jx5gMevrLfQ//uU++/H39QtfHkPry2ONX/hy64c/fvPR/70v1/3XfPnPO97Er8/8hZ/+5y0cv3/D/TcO+Bqtv+5b+L0T1uln4KeW/8rXr/4F+OlNfuHrt3p9/bZf+foz+uvP/KWvX/36OTt+6ev75z/rVx7/872V36+XX/kdnKt/h3/qt//KAXgJ/pw1f+UA5Xdgv/IdrMV34fNLv4PSbwM/PeKvfP0OfP1vPQdf//tbX687+ifQMzZO2P/3CfrbJ0jYqhMk/PxGJfq9E3TsfhB0HP2NE373UYj+Flb8ynvRXv1WtJf9ytfP1t/zl/QP9I/9Qik2/Bo/b0TrL/3yhbfyn7+b/uNfrvhy1fEf//I98Ng9v39/8ZcLqog8ReQvV8d70N7+V33588T9B74cP7vEL3y5Q91/5csDXx5/nfpvfvnZ/4kt7JH++mPyH//+HW/+rr/wqnHv5879F35vPbr4x/C/6svnL/zsK/DYrzjPYz/+8petBl63zwPw/5wg8/dqj3X91vcX+P+uPbJ+5y8A0W5BTMf8lRNsde0x2/uXTtj4Hux5//yPnDCfE37zcdC/top/L5e/ror/3gl/WRX/3cfBfeAPurV+46fQ3yuEm28p+zdr2e+fgEfyx7v5pROOLJxg668+QX7lBMFz8WMP/dL3II6/zuQ3i8vvnqAT3bmuX/oe9PAEXb9QofgXxv4x4H7lXe6MgwK/fukEYW8nYr90gvEE/833avudV5bGwWsznm9C/+LvwSYeB1vxKz+FTTwXtvWXTjjoluzXHknjc2FPzf8PnOD4S2P/GEC/ckJsfA8h85dOMH4P/puPg//uu5zwffJ5h/l/j5i/Z76he5rzVw5w/Eb53n/ld/BrB8TpDiZs/NIB+GX4mXr80oMQ6IB+9YSfr+MRz9vsrx6xf/HnEJ6wfu3JcJ6wf+3H0ENL8pd+qX8cJbwu5tRf+y7gSv/yEXPxiG1/9RHnV3+QwSPsF58R+mtPO/Yf+kH4CvmZaP/SEQst/vyx237p/fLwV+vYb/4gc/zeXzuo4urxayfg0fz1ExbagF8rHILa89MW6m9/E/JXPxDyVz8Q8p/5QKjhnUJj/PY3Eb/n/uCP+L2fCYD+B47Y/Ct8+281dvN3XfyJ7+L8ODK/ccTvPhbGv7ps//ZjMX/HDPp5VeG78PGbj8XvHuGKeYY/L9L/9wj5Tz1C9wiYGst/6eF87NzfeY190am/9uH0v/qxWOM/9Yi/7OH8S7vlWL/Qb/+M6eAz/tTV33w+virz22Oa0c/p2kt/7Yy1N+eVv3OG/tXvF8v+2veLv/jx/L/r8X/5+a+//4c//cv/nW/NUKOMCjVesAZviB/YFZ658AVGOzwjHZ65cBq+kzs8c8EavOBL0XzuW6ZoLqyGPlD7wC9Fc0Eb+kDFgVHw5WqkI4x54BenuXAa+kDrA78UygVv6AO9D/ziNBdWQx/4pWguaEMf6H3gF6dJ+OJhF/rA6AO/hNiF09AHfuGwC95QB2aE8cJsWA11YEYYL0iDNtSBmVxMmKOhD5x94NwNp6EPnH3gtIZ6djLLmAeu2bAa+sDVBy5p0IY+cOHAenbWHg194N4Np6EP3H3gtgZv6ANPH3hmw2roA480aEMfePrA08+O9LMjfaD0gdLPjvSzI32gWEM/O9IHah+o/exoPzvaB2ofqP3saD872gdqP93Wz471gdYHWj871s+O9YHWB1o/O9bPjveB3k+397PjfaD3gd7Pjvez432g48B+dqKfnegDo5/u6Gcn+sDoA6OfnehnJ+rAPUbDbFgNdeAe0qANdeAe3lDPzp6joQ+cfeDcDaehD5zW4A194OoD12xYDX3g6gOXNGhDH7jq6d57NHzp/fnBavjy++uD8zUHH8g3//hA+1PWn/L+VNSnvtdOfup77eSnvtfO/dTuT53+lPSntD9l/SnvT0V96nsR5ae+F1F+6nsR3U/t/tTpT0l/SvtT1p/y/lTUp75XU37qezXlp75X0/1UPxraj4b2o6H9aGg/GtqPhvajYf1oWD8a1o+G9aNh/WhYPxrWj4b1o2H9aFg/Gt6Pxvf60u+p/F5fX3Rqf6+v+y+n/0X6X7T/xfpfvP8l6l++11f+S/TJ0SdHnxx9cvTJ0SdHnxx9ctTJZ9TJZ8z+l9X/svtfTv+L9L9o/4v1v3j/S588++TZJ88+Oa9HiQ9OgzRogzV4QxR8L70Ls2E19MmrT1598uqTV5+8+uTvNWg/ndX5XoMXZsN3ycv8YDec/pQ0aIP1/8cb+uTTJ58++fTJp08+ffLpk0+f/L0GL3hD1Fd9r8ELffL3GrywG/pk6ZO/1+D9qv6epU+W/p61v2ftk7VP1v6ev9fghT5Z+3vW/p61T9Y+2fp7/l6DF/pk6+/Z+nu2Ptn6ZOvv2fpxtj7Z+3v2/p69T/Y+2ft7/l6DF/pk7+/Z+3v2Pjn65OjvOfoZjD45+nuO/p6jT44+Ofp7jnoGZdTJMmbDatgNp0H6q7TB+lPeUN+zzD559smzvmeZu6FPntKgDX3y7JNnf89rNPTJq7/n1d/z6pNXn7z6e17W0Cf3a1D6NSj9GpTdJ/drUPZp+E4+H2iDNXhDFORr8MvG52swYTXshu9k+0AatMEavpP9gyjI12DCbFhf2PqD3XAapEG/gc4H1uANUfC9Bl0+mA2rYTd8J+c1ANLwnfx9q99r8II3RMH3GvysE/legxe+k+OD3XAapEG/HM4H9sXBP/CGKPhegxd+Tv5GV/K9Bi/sb/7xwWmQBm34Tv5+ru81eOE7+fu5vtfghdmwGr6Tv5/iew3G961+r8ELeVXY9wsUBnJQFOnIK8O+y0bHBC3QBp0c3XwkIAWlxnfpxb32LCk1vssw7tVnSRO0ch7z0QYdkIAUlJf2fd9LXqB2KZryErVLE7RAG3RAAlIQNBY0FjQ2NDY0NjQ2NDY0NjQ2NDY0NjQ2NA40Tmp8j2Re/XkpNb7H7xyQgBRkIAdFU14Xeik14qMF2qADElBerfpde5yXh17K61XzCuRoyitEL03QAm3QAQlIy7zUvFD0koOiKa8VvTRBC7RBByQgaBg0DBoGDYeGQ8Oh4dBwaDg0HBoODYeGQyOgEdAIaAQ0AhoBjYBGQCOgEa1hY4AmaIE26IAEpCADOQgaExoTGhMaExoTGhMaExoTGhMaExoLGgsaCxoLGgsaCxoLGgsaCxoLGvk6/7JFtqu0WZbjhN1wGqq02fcSv2AN3lClzb6X94XZsBqqtNn30r4gDdpgDd4Qt/zZ96K+MG+xsyzHCbvhNMgtf5blOMEavCFu+bMsxwmzYTXsWxntexl/5c++V/EFbbAGvwXRvldwwvcCjtwyMBtWw244tyDa99q9oA1266BlOU6oomk+GuYtkZbl+PuesxwnZEkbHwlIQVnSvu87X7KXoikGKEva99PkS/bSBqXG943kS/aSglLje0JuaU7qsun3JTs+mqAF2qAD6nLjQ0EGclCXG58DNEELtEEHBI0JDZRmR2l2lGZHaXaUZkdpdpRmR2l2lGZHaXaUZkdpdpRmR2l2lGZHaXaUZkdpdpRmR2l2lGZHaXaUZkdp9gMNlGa/pTmpS7OjNDtKs6M0O0qzozQ7SrPf0pzUpdlRmh2l2VGaPUvzpS7NfktzUpdmR2l2lGZHaXaUZkdpdpRmz9J8qd9CHaXZUZodpdlRmh2l2VGaHaXZUZodpdlRmh2l2VGaHaXZUZodpdlRmh2l2VGaHaXZUZodpdlRmh2l2VGaHaXZUZodpdlRmh2l2VGaHaXZ8y/h+K7QHw2zYVX9iVHVJsZpkAZtqGoTwxui4Ht1X6hqE3M17IbTUNUmpjZYgzdEwRoN85ad+F7RF6raxDoN0qAN1lDVJnJdygd7NMyGqjaxd8NpkIb6Ey12VZvY3lB/osUZDfUnWpzVUNUmzmmQBm2oP9HieEMUSFWbkNmwGnbDuYUopP5Ei+/1eqH/QgtxUP+FFtqlJnSCFmiD+i+0UAEpqP9CC3VQNFn/hRY2QQvUpSbsgASkIAP122dYv32GD9AELdAGHZCAFGQgaDg0AhoBjYBGQCOgEdAIaAQ0AhrRGj9PyiBO4iJu4iEKUYlGdCLVJtUm1SbVJtUm1W6Z1kQldvH5QScGcA3iJC7iJh5iF6EfVKIRnRjA22jPxEnsWvRFRYmHKEQlGtGJATz9Xv6Dk7iIm3iIQlSiEZ0YQKGaUE2oJlQTqgnVhGpCNaGaUE2pplRTqinVlGpKNaWaUk2pplQzqhnV0s7O5zX97EsHJFXUfrBK1w8ZyEHR5FW+fmiCFmiDqoR9uWCQggxUZeyHoikGaIIWaIPKb/whAVU5+yEDOahMx5k7c4qqps3cmlO0QQdUdW3m5pwiAzkobtmbuT3nK24z1+cULdAGnVvyZq7QKaoSN3OJTpGDoul7c/jq3cxFOkULVJVu5oq0IgEpyG4hnLl8J/Ln+N4TLuVbwlf3Zq7kaVzELngzN/Q0ClGJVuVv3p1qhQHMt4SR31a+JRQu4q4iOHOzT6MQu/rNu4mt0IkBlEHEW/ndyVa4iYcoRCUa0YkoHHdHWyHVlGpKNaWaUk2pplRTqinVjGpGNaOaUc2oZlQzqhnVjGpGNaeaU82p5lRzqjnVnGpOtdtT5DN/m4rEQFGcMYmLuImHKEQlGhFFcQaK4rrtxcVJXMTdpfJugytEUbwb4QqN6EQUxbsZrnASFxGFY8G3mwvG3Vxw7uaCdTcXvLu5YN7NBfduLth3c8G/m2tRbVFtUW1RbVFtUW1RbVNtU21TbVNtU21TbVNtU21TbVON7cVie7HYXiy2F4vtRQa4skJmgqvIQN5Vc/Xgba6evM3Vo7eZQa6irourp29z9fhtZqqrqOvi6gncXD2Cm5nsKuq6uHoKN1eP4Wamu4oEpCCrWplRr6Kuixn2KpqgBdqgrouZ+CpSkIG6Li6LJh+gCVpVNTMClnUxM2BFAlKQVa3MHFhR18VMghVN0ALtqpAZCysSUNfFTIYVOaj8zJnhsKyamQ7LWpnxsKLd9XGPQxQiiuIeRnRiAO+4bidO4iLuro8ZH2sUonZ9zDRZoxNRFPcaxElcxE3EW/mGRTg3PMIfNKITUTg2fMK5YRTODadwbliFc2+qbaptqm2qbaptqh2qHaodqh2qHaodqh2qHaodqh2qCdXYXmy2F5vtxWZ7sdlebLYXm+3FZnux2V5sthdbe1I5ty4iiuLWQxSiEo3oRPxdum0QURS3LeImHqIQe3A5M87WiKKYkbZCH8RJXMRNPEQhonBsGIxzw2GcGxbj3PAY54bJODdcxrlhM84Nn3FuGI1zB9WCakE1zAHnwSBwHkwC58EocB7MAufBMHAeTAPnwThwHswD58FAcJ5BtUm1SbVJNbYXh+3FYXtx2F4cthcZkMsKmQm5S2uAZlfNTMllXcyYXNEBCajrYkblihwUTbvrYsblihZog7ouZmSuSEEGclD/TZq5uayVGZwr6rqY0bmiAxKQgrouZn6uKJpkgLouZoauaIMOSKpqZo4u62IG6YocFE3fW0TWygzTFXVdzDhd0QEJqIZ8MyN1RQ7qupipuqIJWqAKyMxM1mWtzGhdUQ/7ZqbrGp2IopgZu8ZJXMSe+c3jhyjEHvvN40Z0Yk/+5olBnEQUxRObeIhCVCLeyg/8zHloaAoNTaGhKTQ0hYam0NAUGppCQ1NoaAoNTaGhKTQ0hYam0NAUGppCQ1Mm1SbVJtUm1SbVFtUW1RbVFtXYXgjbC2F7IWwvhO2FsL0QthfC9kLYXgjbC7nthSYKEUVRthGdiKIoZxAncRE3EUVRjhCVaEQnRpfKzPs1oihm5q9xEw9RiEo0ohNROISGptDQFBqaQkNTaGgKDU2hoSk0NIWGptDQFBqaQkNTjGpGNaOaUc2oZlQzqhnVnGpONaeaU82p5lRjeyFsL4TthbC9ELYXmSDMCpkRwqINOl01M0Zo90sUZCAHdV3MHGHRBC1Q18XMERYJSEFdFzNHWNR1MXOERRO0QLtqZeYIi7ouZo6wyEAO6r9JM0eYdTFzhEULtEFdFzNHWKQgA3lVzcwRZl3MHGHRBC3QrlqZOcKirouZIywykINqIjkzR1g0QV0XM0dYdEAC0qqamSPMWpk5wqKeTM4bJCycRBTFmyUsPEQh9oBy3jxhoRN7RjlvpLBwEntMOW+qsPAQURQrWHjRiE7E36VKQ1NpaCoNTaWhqTQ0lYam0tBUGppKQ1NpaCoNTaWhqTQ0lYam0tBUGppKQ1NpaKpTzakWVAuqBdWCakG1oFpQje2Fsr1QthfG9sLYXhjbC2N7YWwvjO2Fsb2oBKImOhFFsUKIFydxETfxEIWoRBTFCiNehFlbccSLk7i6VN5EYiGK4s0kFirRiE7E36UVTLw4iSgcRkPTaGgaDU2joWk0NI2GptHQNBqaRkPTaGgaDU2joWmclxrnpcZ5qXFeapyXGuelxnmpcV5qnJca56XGealxXmqclxrnpcb2wtheGNsLY3thbC8y25gVMsONRQqyrpoZcLT7Je3VZsSxaIK6LmbKseiABNR1MZOORQ5qrzbDjn5vwDBBC7RBByQgrVqZgceirosZeLwUAzRBC9R1MQOPRQJSUNfFDDwWtVebgceiWVUzA49ZFzPwWHRAAtKqlRl4LOq6mIHHS3OAJqhnmBl4LDqgrosZeCwykIOiqmYGHrNWZuCxCBPMm3gsPEQUxRt6LDSiEzHBvMHHwknEBPNmHwsPERPMG38sNCKKYiUgE88gTuIi4q3caWg6DU2noek0NJ2GptPQdBqaTkPTaWg6DU2noek0NJ2GptPQdBqaTkPTaWg656XOealzXuqclzrnpc55qXNe6pyXOuelzvbC2V442wtne+FsL5zthbO9cLYXzvbC2V5UVDKfeZ9EFMVKS148RCEq0YhORAmu0GT+2sckLuImHqJ0qbzRyUIUxRueLERRzPxk4yQu4iYeIgpH0NAMGppBQzNoaAYNzaChGTQ0g4Zm0NAMGppBQzNoaAbnpcF5aXBeGpyXBuelwXlpcF4anJcG56XBeWlwXhqclwbnpcF5abC9CLYXwfYi2F4E24sMYmaFzCRmUXu1mcW8VTPTmFkXM45ZtEEH1HUxI5lFBnJQ18WMZRZN0AJ1XcxoZpGAFGQgB9VVFzPTmUVdFzOdWbRBBySgrouZzixyUHu1mc7MupjpzKIF2qBTVTPTmVkXM51ZZCAH1ZUYM9OZRV0XM51ZtEEH1DPMTGcWGajrYvSFjDP6SsYZfSnjzHRmVs1MZ2atjL6acd50ZtbHwAWNM3BF47wBzSyKN6H54Rq4qHENXNW4bkLzq4/rJjQLD7EnmOsmNAuN2BPMNXB14xq4vHFVQnMkLuImHqIQ+618DRiaa8DQXAOG5howNNeAobkGDM01YGiuAUNzDRiaayyqLaotqi2qbaptqm2qbaptqm2qbaptqm2qbaodqh2qHaodqh2qHaodqh2qHaodqgnVhGpCNelLOlYlNC92UVyV0LxoRCcGUAdxEhexi+KqhOZFISrRiH2Fx7oJzYvWRXHdhGbhIm7iIQpRiUbswrEGDM01YGiuAUNzDRiaa8DQXAOG5howNNeAobkGDM01nGpOtaBaUC2oFlQLqgXVgmpBtaAa5qVrYl66Juala2JeuibmpWtiXrom2os10V6sifZiTbQXaw6qzZphroxxFi3Qrqq57m1t75cISEEGqrq4Msd5aQ3QBFVdXJnjLDogAVVdXJnjLHJQNO0BmqC6RGRliLOo6uLKCGeRggzkoKqLK9ObRRO0QFUXVyY3iwSkILtVc2VqM/LRONEkAzRBddnIysBmUdXFlXHNIgUZqGaYK6Oal3SAqi6uzGkWbdABya2aKzOakT+HGqgnmOsmNC/aIKIo3oRm4SYeYk8w101oFhqxJ5jrJjQv+iD2BHPdhGbhJqIoVkLzohKN6ES8lU8YmmvC0FwThuaaMDTXhKG5JgzNNWForglDc00YmmvC0FwLhuZaMDTXgqG5FgzNtWBorgVDcy0YmmthXroW5qVrDapNqk2qTapNqk2qTaqxvVhsLxbbi8X2YrG9WGwvFtuLxfZisb1YbC8qoamJRkRRrIRm4h7ESVzETTxEIaIoVkLzohMDeAaxLzdZN6FZiKJ4E5qFQlSiEZ0YQBlEFI4FQ3MtGJprwdBcC4bmWjA014KhuRYMzbVgaK4FQ3MtpZpSTammVFOqKdWUako1pZpRzahmVDOqGdWMakY1oxrbi8X2YrG9WGwvFtuLjHFmhcwYZ5GAtKtm5jjtfomDoikGqOti5jiLNuiAui5mjrPIQA7qupg5zqIJKq92ZY6z6IDqepOVIc6irosZ4SyKpjlAE9R1MdObRQckoK6LmdwsclA0pcc5k7ouZmizaIMOqK43WRnYLOq6mHHNomjaA1QzzJVRzaIN6rqYOc0iBRnIq2pmRjNrZUY0i3qCuW5Cs3ATURRvQrNQiUbsCea6Cc2LMog9wVw3oVm4iT3BXDehWahEFMVKaF4MoA7iJOKtfMPQXBuG5towNNeGobk2DM21YWiuDUNzbRiaa8PQXNuoZlQzqhnVjGpGNaOaUc2p5lRzqjnVnGpONaeaU82pxvZis73YbC8224vN9mKzvdhsLzbbi832YrO9qITm98xXQvMiimIlNC9u4iEKUYlGdCKKYiU0L07iIm5iX26ybkKzEEXxJjQLnYiimBnNxklcxE1E4TgwNNeBobkODM11YGiuA0NzHRia68DQXAeG5jowNNfZVNtU21TbVNtU21Q7VDtUO1Q7VDtUO1Q7VDtUO1Q7VBOqsb04bC8O24vD9uKwvbjrEPN5FQM5KLpq3p2I+SU6QQu0QV0XM8dZpCADdV3MHOclG6AJ6rqYOc6iAxKQggxU15usDHFe8q6LGeEsWqANOqCui5neLDKQg7ouZnKzaIIWaFfVzNRm1sUMbRYpyEB1vcnKwGZS5jWzLmZcs2iBNqhmmCujmkUK6rqYOc2iaJoDNKtqZkYza2VGNIt6grluQrNQiSiKN6FZCLP2JjQLe4K5bkKzcBN7grluQrNQiT3BXDehWQizthKa+Z3tSVzETTxEvJULDU2hoSk0NIWGptDQFBqaQkNTaGgKDU2hoSk0NIWGptDQFBqaQkNTaGgKDU0RqgnVhGpCNaGaUE2oplRTqrG9ELYXwvZC2F4I2wtheyFsL4TthbC9ELYXldDMZ942EUWxEpoXlWhEJ+Lv0kpoXpxEFMVKaF48RCEqsS83WTehWYiieBOahZO4iJt4iEJUIgqH0NAUGppKQ1NpaCoNTaWhqTQ0lYam0tBUGppKQ1NpaOqk2qTapNqk2qTapNqk2qTapNqk2qLaotqi2qIa2wtle6FsL5TthbK9yBhnVsiMcRZN0Oqqqb0pbmmviluZ4yxSUNdF7XVxK3Ocl84AdV3UXhm3MsdZdEBdF7XXxi3tvXFLe3HcyhznJRmgut5kZYizqOui9vq4lQnOIgUZqOtipjcv6QBNUNfFTG4WHZCAtKqm9i65laHNovZqM7JZVNebrAxsFnVdzLhmkYAUVDPMlVHNovZqtRfLrcxpFi3QBp2qmpnRzFqZEc2inmCum9AshFmr2C+3bkKzcBE3ERPMm9AsVCImmDehWQiz9iY0sz7ehGbhIqIoGrbNrUpoXlSiEfFWbjQ0jYam0dA0GppGQ9NoaBoNTaOhaTQ0jYam0dA0GppGQ9NoaBoNTaOhaTQ0jfNS47zUOC81zkuN81LjvNQ4LzXOS43zUmN7YWwvjO2Fsb0wthfG9sLYXhjbC2N7YWwvKqGZz/xRIoqiYTPdMqymW4bddMuwnG5VQvPiJh4iiqJhQ92qhOZFJ+Lv0pvQzFJ5E5qFKIqGRXXLsKluGVbVLcOuulUhzYtORAk2GppGQ9NoaBoNTaOhaTQ0jYam0dA0GppGQ9NoaBoNTaOhaZyXGuelxnmpcV5qnJca56XGealxXmqclxrnpcZ5qXFeapyXGuelxvbC2F4Y2wtne+FsLzLGmRUyY5xFByRdNb3X2q3McRY5qL1a79V2K3OcRQu0QV0XM8dZpCADdV303nG3vJfcrcxxFi3QBtX1JitDnEVdF7133a1McBa1V5v5zaKui5neLNqgA+q6mMnNIgM5KKpqei++WxnaLFqgDarrTVYGNou6LmZcs8hB7dVmVjMrZEY1ixao62LmNIsEpCCrqpkZzayVGdG8pJhg3oRm4SKiKN6EZqEQlYgJ5k1oFsKsvQnNrI83oVm4iJhg3oRmoRBRFB2r8VYlNC/CrK2E5kW8lTsNTaeh6TQ0nYam09B0GppOQ9NpaDoNTaeh6TQ0nYam09B0GppOQ9NpaDoNTee8NDgvDc5Lg/PS4Lw0OC8NzkuD89LgvDTYXgTbi2B7EWwvgu1FsL0IthfB9iLYXgTbi0poaiLM2sDCvBVYmLcCC/NWYGHeCizMW5XQvKhEI6IoBhbmrUpoXpzERezLTdZNaBaiKAYW5q3AwrwVWJi3AgvzVoU0L07iIqJwBA3NoKEZNDSDhmbQ0AwamkFDM2hoBg3NoKEZNDSDhmZwXhqclwbnpcF5aXBeGpyXBuelwXlpcF4anJcG56XBeWlwXhqclwbbi2B7EWwvgu1FsL3IGGdWyIxxFhnIu2pG78xbmeMsmqAF6rqYOc4iASmo62LmOIvaq80cZ1HXxeideSt6Z97KHGeRgBRU15usDHEWVV3co3fm7UxwFi3QBlVd3JneLFKQgaou7kxuXpoDNEHrVs09emfeztBmkYAUVNeb7AxsFlVd3BnXLJqgBaoZ5s6oZpGAqi7uzGkWOSiack6aP+Wu6012RjSLeoK5b0KzUIhdFPdNaBY6MYCnJ5j7JjQLF7EnmPsmNAuF2BPMfROahU7sorgHFubtSmheXMRN7LfyPWBo7gFDcw8YmnvA0NwDhuYeMDT3gKG5BwzNPWBo7qFUU6op1ZRqSjWlmlHNqGZUM6oZ1YxqRjWjmlHNqOZUc6o51ZxqTjWnmlPNqeZUc6oF1aIvN9mV0LzYRXEPLMzbAwvz9sDCvD2wMG9XQvNi/126K6F5sYvinliYtyuhefEQhdiXm+yb0CzsorgnFubtiYV5e2Jh3g8u4iYeohC7cOwJQ/MHnRhAGJp7wtDcE4bmnjA094ShuScMzT0X1RbVFtUW1TbVNtU21TbVNtU21TbVNtU21TbVDtUO1Q7VDtUO1Q7VDtUO1U7NMHfGOC/JAM2qmnv2zrydOc6iAxJQ1cWdOc4iB0VT78zbmeMsWqANqrq4Z+/M27N35u3McRY5KJqsrjfZGeIs6ro4e2fezgRnkYAU1HUx05tF0eQD1HUxk5tFG3RAUlVz9s68naHNIgdFU9T1JjsDm0VdFzOuWXRAAqoZ5s6oZpGDui5mTrNoghZoV9XMjGbWyoxoFvUEc9+EZqETURRvQrNwEhexJ5j7JjQLhdgTzH0TmoVO7AnmvgnNwklEUVxYmLcroXlRiErEW/mCobkXDM29YGjuBUNzLxiae8HQ3AuG5l4wNPeCobnXptqm2qbaodqh2qHaodqh2qHaodqh2qHaoZpQTagmVBOqsb1YbC8W24vF9mKxvVhsLxbbi8X2YrG9WGwvKqGZz7wKEUVxYWHeXliYtxcW5u2FhXm7EpoXF3ETURQXFubtSmheNKIT+3KTfROahSiKCwvz9sLCvL2wMG8vLMzbFdK8aEQnonAsGJp7wdDcC4bmXjA094KhuRcMzb1gaO4FQ3MvGJp7wdDcG4bm3jA098a8dG/MS/fGvHRvzEv3xrx0b8xL98a8dO9BtUm1SbVJtUm1SbVJNbYXm+3FZnux2V5sthcZ48wKmTHOog06XTV378zbmeMsMpCDui5mjrNoghao62LmOIsEpKCui7t35u3dO/N25jiLJmiB6nqTnSHOoq6Lu3fm7UxwFjmo/ybdvTNvZ3qzaIE2qOtiJjeLFGQgr6q5e2feztBm0QQtUF1vsjOwWdR1MeOaRQZyUM0wd0Y1iyao62LmNIsOSEBaVTMzmlkrM6JZ1BPMfROahZOIongTmoWHKMSeYO6b0Cx0Yk8w901oFk5iTzD3TWgWHiKK4sbCvF0JzYtOxN+lB4bmPjA094GhuQ8MzX1gaO4DQ3MfGJr7wNDcB4bmPjA095lUm1SbVJtUm1SbVJtUm1SbVJtUW1RbVFtUW1RbVFtUW1Rje3HYXhy2F4ftxWF7cdheHLYXh+3FYXtx2F5UQlMTnYiieLAwbx8szNsHC/P2wcK8fXAXr31wG699cB+vfbAwbx8szNuV0EyUQZzEvtxk34RmIYriwcK8fbAwbx8szNsHC/P2wU299sFdvfbBbb32gaG5DwzNfWBo7gNDcx8YmvvA0NwHhuY+MDT3gaG5DwzNfYxqRjWjmlHNqGZUM6oZ1ZxqTjWnmlPNqeZUc6o51ZxqbC8O24vD9uKwvThsL+7Nr/N5DQEpyLpqnt6Zt+8tsD+698C+NEFdFzPHWXRAAuq6mDnOIgdFU+/M29I787b0zrydOc6iAxJQXW+yM8RZ1HVRemfezgRn0QQtUNfFTG8WCUhBXRczuVnUXm3mNotmVU3pnXk7Q5tFBySgut5kZ2CzqOtixjUvnQGaoJph7oxqFh1Q18XMaRYZyEFRVTMzmlkrM6JZ1BPMfROahYeIongTmoVGdGJPMPdNaBZOYk8w901oFh5iTzD3TWgWGhFFUbAwb1dC8+IkLiLeyoWGptDQFBqaQkNTaGgKDU2hoSk0NIWGptDQFBqaQkNTaGgKDU2hoSk0NIWGpgTVgmpBtaBaUC2oFlQLqmFeupXthbK9ULYXyvZC2V4o2wtle6FsL5TthbK9qISmJk4iiqJiYd5WLMzbioV5W7EwbytuMLYVNxjbihuMbcXCvK1YmLcroXlxEw+xLzfZN6FZiKKoWJi3FQvztmJh3lYszNuKG4xtxQ3GtuIGY1tpaCoNTaWhqTQ0lYam0tBUGppKQ1NpaCoNTaWhqTQ0lYamHqodqgnVhGpCNaGaUE2oJlQTqgnVhGpKNaUa2wtle6FsL5TtBe/qvTPGmRUyY5xF7dXezZtZNbV35u3McRZt0AF1XcwcZ5GBHNR1MXOcRRO0QF0XtXfmbe2deTtznEUGclBdb7IzxFnUdVF7Z97OBGfRAQmo62KmN4sc1F6t9c68ncnNogXaoFNV03pn3s7QZpGBHFTXm+wMbBZ1Xcy4ZtEGHVDPMDOqWWSgrouZ07y0BmiCVlXNzGhmrcyIZhEmmDehWWhEFMWb0Ly4B3ESMcG8Cc3CQ8QE8yY0C42ICeZNaF48g4iiaFiYtyuhefEQhYi3cqOhaTQ0jYam0dA0GppGQ9NoaBoNTaOhaTQ0jYam0dA0GppGQ9NoaBoNTaOhaZyXGuelxnmpcV5qnJca56XGealxXmqclxrbC2N7YWwvjO2Fsb0wthfG9sLYXhjbC2N7UQnNfOb9EFEUDQvztmFh3jYszNuGhXnbcIOxbbjB2DbcYGwbFuZtw8K8XQnNi0o0Yl9usm9CM9GxMG87FuZtx8K87ViYtx0L87bjBmPbcYOx7bjB2HYamk5D02loOg1Np6HpNDSdhqbT0HQamk5D02loOg1Np6HpnJc656XOealzXuqclzrnpc55qXNe6pyXOuelznmpc17qnJc656XO9sLZXjjbC2d74WwvMsaZFTJjnEULtLtqeu/M25njLFKQgbouZo7zkgzQBHVdzBxn0QEJqOui98687b0zb2eO85IO0ATV9SY7Q5xFXRe9d+btTHAWGchBXRczvVk0QQvUdTGTm0UCUpBV1fTembcztHnJB2iC6nqTnYHNoq6LGdcsUpCBeoaZUc1LMUBdFzOnWbRBByRVNTOjmbUyI5pFmGDehGbiTWgWoijehGbhJh4iJpg3oVloREwwb0Lz4hxETDBvQrNwE1EUAwvzdiU0LxrRiXgrDxqaQUMzaGgGDc2goRk0NIOGZtDQDBqaQUMzaGgGDc2goRk0NIOGZtDQDBqawXlpcF4anJcG56XBeWlwXhqclwbnpcF5abC9CLYXwfYi2F4E24tgexFsL4LtRbC9CLYXldDMZ16MiKIYWJi3AwvzdmBh3g4szNuBG4ztwA3GduAGYzuwMG8HFubtSmhehFlbCc2LfbnJvgnNQhTFwMK8HViYtwML83ZgYd4O3GBsB24wtgM3GNtBQzNoaAYNzaChGTQ0g4Zm0NAMGppBQzNoaAYNzaChGTQ0g/PS4Lw0OC8NzkuD89LAvPQMzEvPwLz0DMxLz8C89AzMS8/AvPQMzEvPwLz0DLQXZwyqTapNqk2qzZphnoxxFglIq2qe0TvzTuY4i6JpDVDVxZM5zqINOqCqiydznEUGclDVxTN6Z94ZvTPvZI6zaIMOqK43ORniLKq6eEbvzDuZ4Lx0BmiCqi6eTG8WHZCAqi6eTG4WOSia0uOcSVUXT4Y2izbogOp6k5OBzaKqiyfjmkXRpANUM8yTUc2iDaq6eDKnWaQgA/mtmiczmpE/hw1QTzDPTWgWbmIXxXMTmoVKNGJPMM9NaF70QewJ5rkJzcJN7AnmuQnNQiV2UTwDC/NOJTQTYxAnsd/Kz4CheQYMzTNgaJ4BQ/MMGJpnwNA8A4bmmTA0z4SheSYMzTNhaJ4JQ/NMGJpnwtA8E4bmmTA0zxxUm1SbVJtUm1SbVJtUm1SbVJtUm1RbVFtUW1RbVFtUW1RbVFtUW1RbfbnJqYTmxS6KZ2Jh3plYmHcmFuadiYV5Z+IGY2fiBmNn4gZjZ2Jh3plYmHcqoXlxETexLzc5N6FZ2EXxTCzMOxML887EwrwzsTDvTNxg7EzcYOxM3GDsTBiaZ8LQPBOG5pkwNM+EoXkmDM0zYWieCUPzTBiaZ8LQPFOpplRTqinVlGpKNaOaUc2oZlQzqhnVjGpGNaOaUc2p5lRzqjnVnGpONa8Z5skYZ5GDoqvm7J15J3OcRQu0QV0XM8dZpCADdV3MHGdS5jiLJqjr4uqdeWf1zryTOc4iBRmorjc5GeK81DvzzuqdeScTnEUbdEBdFzO9WWQgB3VdzORm0QQt0K6quXpn3snQZpGCDFTXm5wMbF7qnXkn45pFC7RBNcM8GdUsUlDXxcxpFkXTGaBZVTMzmlkrM6JZ1BPMcxOahUpEUbwJzcIAyiD2BPPchGbhJvYE89yEZqESe4J5bkKzMIBYmHcWFuadSmhe3MRDxFv5gqF5FgzNs2BongVD8ywYmmfB0DwLhuZZMDTPgqF5llHNqGZUM6oZ1ZxqTjWnmlPNqeZUc6o51ZxqTrWgWlCN7cVie7HYXiy2F4vtxWJ7sdheLLYXm+3FZntRCU1N3EQUxY2FeWdjYd7ZWJh3NhbmnY0bjJ2NG4ydjRuMnY2FeWdjYd6phOZFISqxLzc5N6FZiKK4sTDvbCzMOxsL887GwryzcYOxs3GDsbNxg7GzYWieDUPzbBiaZ8PQPBuG5tkwNM+GoXk2DM2zYWieDUPz7E21TbVNtUO1Q7VDtUO1Q7VDtUO1Q7VDtUM1oZpQTagmVGN7sdlebLYXm+3FZnuRMc6skBnjLJqg1VVz9868kznOIgEpqOti5jiLoskGqOti5jiLNuiAui7u3pl3du/MO5njLOq/SXffW+xkijNrZYY4i7ou7t6ZdzLBWaQgA3VdzPTmpRigCeq6mMnNogMSkFbV3L0z72Ros6i82pORzaK63uRkYLOo62LGNYsEpKCaYZ6MahZFU+/MO5nTLFqgDTpVNTOjmbUyI5pFPcE8N6FZGEAszDs3oVm4iJvYE8xzE5qFSuwJ5rkJzcIA7p5gnpvQLFxEFMWDhXmnEpoXlWhEvJUfGJrnwNA8B4bmOTA0z4GheQ4MzXNgaJ4DQ/McGJrnHKodqgnVhGpCNaGaUE2oJlQTqgnVhGpKNaWaUk2pplRje3HYXhy2F4ftxWF7cdheHLYXh+3FYXtx2F5UQjOfeVMiiuLBwrxzsDDvHCzMOwcL887BDcbOwQ3GzsENxs7BwrxzsDDvVELzohPxd+lNaGapvAnNQhTFg4V552Bh3jlYmHcOFuadgxuMnYMbjJ2DG4wdoaEpNDSFhqbQ0BQamkJDU2hoCg1NoaEpNDSFhqbQ0BQamjKpNqk2qTapNqk2qTaptqi2qLaotqi2qLaotqjG9kLYXgjbC2F7IWwvMsaZFTJjnEUHJF01pXfmncxxFjmovVrpnXknc5xFC7RBXRczx1mkIAN1XZTemXekd+adzHEWLdAG1fUmJ0OcRV0XpXfmnUxwFrVXm/nNoq6Lmd4s2qAD6rqYyc0iAzkoqmpK78w7GdosWqANqutNTgY2i7ouZlyzyEHt1WZWMytkRjWLFqjrYuY0iwSkIKuqmRnNrJUZ0bwUPcE8N6FZuIgoijehWShEJfYE89yEZiHM2pvQzPp4E5qFi9gTzHMTmoVCRFFULMw7ldC8CLO2EpoX8VauNDSVhqbS0FQamkpDU2loKg1NpaGpNDSVhqbS0FQamkpDU2loKg1NpaGpNDR1UW1TbVNtU21TbVNtU21TbVON7YWyvVC2F8r2QtleKNsLZXuhbC+U7YWyvaiEZj7zB2atYmHeUSzMO4qFeUexMO8oFuYdxQ3GjuIGY0dxg7GjWJh3FAvzTiU0L07iIvblJucmNAtRFBUL845iYd5RLMw7ioV5R3GDsaO4wdhR3GDsKA1NpaGpNDSVhqbS0FQamkpDU2loKg1NpaGpNDSVhqbS0FSnmlPNqeZUC6oF1YJqQbWgWlAtqBZUC6pxXmpsL4zthbG9MLYXxvYiY5xZITPGWWQg76ppvTPvZI6zaIIWqOti5jiLBKSgrouZ4yxqrzZznEVdF6135h3rnXknc5xFAlJQXW9yMsRZ1HXRemfeyQRn0QJtUNfFTG8WKchAXRczuXnpDNAEraqa1jvzToY2iwSkoLre5GRgs6jrYsY1iyZogXqGmVHNIgF1XcycZpGD2qvNkGZWzcxoZq3MiGYRJpg3oVkoRBTFm9AsdCLM2pvQzPp4E5qFi4gJ5k1oFgoRE8yb0Cx0IoqiYWHeqYTmxUXcRLyVGw1No6FpNDSNhqbR0DQamkZD02hoGg1No6FpNDSNhqbR0DQamkZD02loOg1N57zUOS91zkud81LnvNQ5L3XOS53zUue81NleONsLZ3vhbC+c7YWzvXC2F872wtleONuLSmhq4iKiKDoW5h3HwrzjWJh3HAvzjuMGY8dxg7HjuMHYcSzMO46FeacSmhcPUYh9ucm5Cc1CFEXHwrzjWJh3HAvzjmNh3nHcYOw4bjB2HDcYO05D02loOg1Np6HpNDSdhqbT0HQamk5D02loOg1Np6HpNDSd81LnvNQ5L3XOS53zUue81Dkvdc5LnfNS57zUOS91zkud81LnvNTZXjjbC2d74WwvnO1FxjizQmaM85IP0Oyq6b0z72SOs+iABNR1MXOcRQ5qr9Z7Z97JHGfRAm1Q10XvnXnHe2feyRxnkYP6b9JMcWatzBBnUdfF6J15JxOcRQJSUNfFTG8WtVeb2c2irouZ3CzaoAOSqprRO/NOhjaLHNRebSY2s1ZmYLOo62LGNYsOSEA9w8yoZpGDui5mTrNoghZoV9XMjGbWyoxoFmGCeROahU5EUbwJzcJJXERMMG9Cs1CImGDehGahEzHBvAnNwklEUQwszDuV0LwoRCXirTxoaAYNzaChGTQ0g4Zm0NAMGppBQzNoaAYNzaChGTQ0g4Zm0NAMGppBQzNoaAbnpcF5aXBeGpyXBuelwXlpcF4anJcG56XB9iLYXgTbi2B7EWwvgu1FsL0IthfB9iLYXlRCM5/5ECKKYmBh3gkszDuBhXkysDBPBm4wJgM3GJOBG4zJwMI8GViYJ5XQvGhEJ/blJnITmoVdFGVgYZ4MLMyTgYV5MrAwTwZuMCYDNxiTgRuMyYChKQOGpgwYmjJgaMqAoSkDhqYMGJoyYGjKgKEpA4amjEW1TbVNtU21TbVNtU21TbVNtU21TbVDtUO1Q7VDtUO1Q7VDtUO1Q7VDNaGa1AxTMsZZtEGnqqaM3pknmeMsMpCDqi5K5jiLJmiBqi5K5jiLBKSgqosyemeejN6ZJ5njLJqgBarrTSRDnEVVF2X0zjzJBGeRg6Kpd+ZJpjeLFmiDqi5KJjeLFGQgv1VTRu/MkwxtFk3QAtX1JpKBzaKqi5JxzSIDOahmmJJRzaIJqroomdMsOiAB6a2akhnNr1ZKRjSLeoIpN6FZOIldFOUmNAsPUYg9wZSb0Cx0Yk8w5SY0CyexJ5hyE5qFh9hFUSYW5kklNC86MYAwNGXC0JQJQ1MmDE2ZMDRlwtCUCUNTJgxNmTA0ZcLQlHmodqh2qHaodqh2qHaodqh2qHaoJlQTqgnVhGpCNaGaUE2oJlQTqinVlGpKNaWaUk2pplTTvtxEKqF5EUVxYmGeTCzMk4mFeTKxME8mbjAmEzcYk4kbjMnEwjyZWJgnldBM9EGcxL7cRG5CsxBFcWJhnkwszJOJhXkysTBPJm4wJhM3GJOJG4zJhKEpE4amTBiaMmFoyoShKROGpkwYmjJhaMqCoSkLhqYsGJqyYGjKgqEpC/NSWZiXysK8VBbmpbIG1SbVJtUm1SbVJtUm1SbVJtUm1dheLLYXi+3FYnux2F5kjDMrZMY4ixRkXTVX78yTzHFe2gM0QV0XM8dZdEAC6rqYOc4iB0VT78yT1TvzZPXOPMkcZ9EBCaiuN5EMcRZ1XVy9M08ywVk0QQvUdTHTm0UCUlDXxUxuFkWTDtCsqrl6Z55kaLPogARU15tIBjaLui5mXPOSDdAE1QxTMqpZdEBdFzOnWWQgB0VVzcxoZq3MiGZRTzDlJjQLDxFF8SY0C43oxJ5gyk1oFk5iTzDlJjQLD7EnmHITmoVGRFFcWJgnldC8OImLiLfyDUNTNgxN2TA0ZcPQlA1DUzYMTdkwNGXD0JQNQ1P2pNqk2qTapNqk2qTapNqi2qLaotqi2qLaotqi2qLaotqiGtuLzfZis73YbC8224vN9mKzvdhsLzbbi832ohKamjiJKIobC/NkY2GebCzMk42FebJxgzHZuMGYbNxgTDYW5snGwjyphObFTTzEvtxEbkKzEEVxY2GebCzMk42FebKxME82bjAmGzcYk40bjMmGoSkbhqZsGJqyYWjKhqEpG4ambBiasmFoyoahKRuGpmyjmlHNqGZUM6o51ZxqTjWnmlPNqeZUc6o51ZxqQbWgGtuLzfZis73YbC8224uMcWaFzBhnUXm1cjdvZtU8vTNPMsdZtEEH1HUxc5xFBnJQ18XMcRZN0AJ1XTy9M09O78yTzHEWGchBdb2JZIizqOvi6Z15kgnOogMSUNfFTG8WOSiaemeeZHKzaIE26FTVPL0zTzK0WWQgB9X1JpKBzaKuixnXLNqgA6oZpmRUs8hAXRczp3lJBmiCVlXNzGhmrcyIZlFPMOUmNAuNiKJ4E5oXdRAnsSeYchOahYfYE0y5Cc1CI/YEU25C86INIoriwcI8qYTmxUMUIt7KDwxNOTA05cDQlANDUw4MTTkwNOXA0JQDQ1MODE05TjWnmlPNqRZUC6oF1YJqQbWgWlAtqBZUw7xUBPNSEcxLRTAvFWF7IWwvhO2FsL0QthfC9kLYXgjbC2F7IWwvKqGpiYeIoihYmCeChXkiWJgngoV5IrjBmAhuMCaCG4yJYGGeCBbmSSU0LyrRiH25idyE5kUszBPBwjwRLMwTwcI8ESzME8ENxkRwg7EfNCIKh9DQFBqaQkNTaGgKDU2hoSk0NIWGptDQFBqaQkNTaGiKUE2oJlQTqgnVhGpCNaGaUE2pplRTqinVlGpsL4TthbC9ELYXwvYiY5xZITPGWbRAu6um9M48yRxnkYIM1HUxc5yXfIAmqOti5jiLDkhAXReld+aJ9M48yRznpRigCarrTSRDnEVdF6V35kkmOIsM5KCui5neLJqgBeq6mMnNIgEpyKpqau/MkwxtXpoDNEF1vYlkYLOo62LGNYsUZKCaYUpGNS+tAeq6mDnNog06IKmqmRnNrJUZ0SzqCabchObFPYgoijehWbiJh9gTTLkJzUIj9gRTbkLz4hnEnmDKTWgWbiKKomJhnlRC86IRnYi3cqWhqTQ0lYam0tBUGppKQ1NpaCoNTaWhqTQ0lYam0tBUGppKQ1NpaCoNTaWhqUo1pZpSzahmVDOqGdWMakY1thfK9kLZXijbC2V7oWwvlO2Fsr1QthfK9qISmvnMuxFRFBUL80SxME8UC/NEsTBPFDcYE8UNxkRxgzFRLMwTxcI8qYTmRZi1ldC82JebyE1oFqIoGhbmiWFhnhgW5olhYZ4YbjAmhhuMieEGY2I0NI2GptHQNBqaRkPTaGgaDU2joWk0NI2GptHQNBqaRkPTOC81zkuN81LjvNQ4LzXOS43zUuO81DgvNc5LjfNS47zUOC81zkuN7YWxvTC2F8b2wtheZIwzK2TGOIsEpF01rXfmSeY4i9qrzRxnUdfFzHEWbdABdV3MHGeRgRzUddF6Z55Y78yTzHEWbdAB1fUmkiHOoq6L1jvzJBOcl2yAJqjrYqY3iw5IQF0XM7lZ5KD2ajO2mVXTemeeZGizaIMOqK43kQxsFnVdzLhmUXu1GdYs6hlmRjWLNqjrYuY0ixRkIK+qmRnNrJUZ0SzCBPMmNAs3EUXxJjQLlWhETDBvQvPiHERMMG9Cs3ATMcG8Cc1CJaIoOhbmSSU0E9cgTiLeyp2GptPQdBqaTkPTaWg6DU2noek0NJ2GptPQdBqaTkPTaWg6DU2noek0NJ2GpnNe6pyXOuelznmpc17qnJc656XOealzXupsL5zthbO9cLYXzvbC2V442wtne+FsL5ztRSU085nXQURRdCzME8fCPHEszBPHwjxx3GBMHDcYE8cNxsSxME8cC/OkEpoXF3ET+3ITuQnNQhRFx8I8cSzME8fCPHEszBPHDcbEcYMxcdxgTJyGptPQdBqaTkPTaWg6DU2noek0NJ2GptPQdBqaTkPTaWg656XOealzXhqclwbnpcF5aXBeGpyXBuelwXlpcF4anJcG56XBeWmwvQi2F8H2ItheBNuLjHFmhcwYZ5GDoqtm9M48yRxn0QJtUNfFzHEWKchAXRczx3lpD9AEdV2M3pkn0TvzJHOcRQoyUF1vIhnivNQ78yR6Z55kgrNogw6o62KmN4sM5KCui5ncLJqgBdpVNaN35kmGNosUZKC63kQysHmpd+ZJxjWLFmiDeoaZUc0iBXVdzJxmUXu1mdIsmlU1M6OZtTIjmkWYYN6EZqESURRvQrMQZu1NaBZignkTmoWbiAnmTWgWKhETzJvQLIRZG1iYJ4GFeVIJzYubeIh4Kw8amkFDM2hoBgxNHTA0dcDQ1AFDUwcMTR0wNHXA0NQBQ1MHDE0dMDR1DKpNqk2qTapNqk2qTapNqk2qTapNqi2qLaotqi2qLaotqi2qLaotqi2qbaptqu2+3EQroXmxi6IOLMzTgYV5OrAwTwcW5unADcZ04AZjOnCDMR1YmKcDC/O0EpoXhajEvtxEb0KzsIuiDizM04GFeTqwME8HFubpwA3GdOAGYzpwgzEdMDR1wNDUAUNTBwxNHTA0dcDQ1AFDUwcMTR0wNHXA0NShVFOqKdWMakY1o5pRzahmVDOqGdWMakY1p5pTzanmVHOqOdWcak41p5rXDFMzxlk0Qauqpo7emaeZ4ywSkIKqLmrmOIvKq9XMcRZVXdTMcRZt0AFVXdTZO/N09s48zRxnUTT1vcU0U5xfrfyhBaq6qLN35mkmOIsUZKCqi5rpzUtrgCao6qJmcrPogASkt2rq7J15mqHNomjaA1TXm2gGNouqLmrGNYsEpKCaYWpGNYuiqXfmaeY0ixZog86tmpoZzcif4yioJ5h6E5qFAcTCPL0JzcJF3MSeYOpNaBYqsSeYehOahQHUnmDqTWgWLmIXRZ1YmKeV0LyoRCPirXzC0NQJQ1MnDE2dMDR1wtDUCUNTJwxNnTA0dcLQ1GlUM6o51ZxqTjWnmlPNqeZUc6o51ZxqQbWgWlAtqBZUC6oF1YJqQTW2F4vtxWJ7sdheLLYXi+1FJTQ1UYkoigsL83RhYZ4uLMzThYV5unCDMV24wZgu3GBMFxbm6cLCPK2E5kUnBnD15SZ6E5qFKIoLC/N0YWGeLizM04WFebpwgzFduMGYLtxgTBcMTV0wNHXB0NQFQ1MXDE1dMDR1wdDUBUNTFwxNXTA0dR2qHaodqh2qHaodqh2qHaodqh2qCdWEakI1oZpQTagmVGN7sdheLLYXi+3FYnuRMc6skBnjLDog6aq5emeeZo6zyEHR1DvzNHOcRQu0QV0XM8dZpCADdV1cvTNPV+/M08xxFi3QBtX1JpohzqKui6t35mkmOIuiKQao62KmN4s26IC6LmZys8hADoqqmrt35mmGNosWaIPqehPNwGZR18WMaxY5KJpmzTA1o5pFC9R1MXOaRQJSkFXVzIxm1sqMaF5aPcHUm9AsXEQUxZvQLBSiEnuCqTehWRjA3RNMvQnNwkXsCabehGahEFEUNxbmaSU0LwbwDCLeyjcMTd0wNHXD0NQNQ1M3DE3dMDR1w9DUDUNTNwxN3UI1oZpQTagmVBOqCdWEakI1pZpSTammVFOqKdWUako1theb7cVme7HZXmy2F5vtxWZ7sdlebLYXm+1FJTTzmbcAYmGebizM042FebqxME83Fubpxg3GdOMGY7pxgzHdWJinGwvztBKaFydxEftyE70JzUIUxY2FebqxME83FubpxsI8PbjBmB7cYEwPbjCmB4amHhiaemBo6oGhqQeGph4YmnpgaOqBoakHhqYeGJp6JtUm1SbVJtUm1SbVJtUW1RbVFtUW1RbVFtUW1RbVFtUW1dheHLYXh+3FYXtx2F5kjDMrZMY4iwzkXTVP78zTzHEWTdACdV3MHGeRgBTUdTFznEXRJAPUdfH0zjw9vTNPM8dZJCAF1fUmmiHOoq6Lp3fmaSY4ixZog7ouZnqzSEEG6rqYyc1LNkATtKpqnt6ZpxnaLBKQgup6E83AZlHXxYxrFk3QAtUMUzOqWSSgrouZ0yxyUDTlnDR/yqjrTTQjmkU9wdSb0CwUIoriTWgWOrHNWr0JzayPN6FZuIg9wdSb0CwUYk8w9SY0C52IoihYmKeV0Ly4iJuIt3KhoSk0NIWGptDQFBqaQkNTaGgKDU2hoSk0NIWGptDQFBqaQkNTaGgKDU2hoSmbaptqm2qbaptqm2qbaptqh2psL4TthbC9ELYXwvZC2F4I2wtheyFsL4TtRSU085mXRURRFCzMU8HCPBUszFPBwjwV3GBMBTcYU8ENxlSwME8FC/O0EpoXD1GIfbmJ3oRmIYqiYGGeChbmqWBhngoW5qngBmMquMGYCm4wpkJDU2hoCg1NoaEpNDSFhqbQ0BQamkJDU2hoCg1NoaEpNDTFqRZUC6oF1YJqQbWgWlAtqBZUw7xUFfNSVcxLVTEvVWV7oWwvlO2Fsr1QthcZ48wKmTHOS3OAZldN7Z15mjnOogMSUNfFzHEWOai9Wu2deZo5zqIF2qCui9o781R7Z55mjrPIQf03aaY4s1ZmiLOo66L2zjzNBGeRgBTUdTHTm0Xt1WZ2s6jrYiY3izbogKSqpvbOPM3QZpGD2qvNxGbWygxsFnVdzLhm0QEJqGaYmlHNIgd1XcycZtEELdCuqpkZzayVGdEs6gmm3oRmoRNRFG9Cs3ASF7EnmHoTmoVC7Amm3oRmoRN7gqk3oVk4iSiKioV5WgnNi0JUIt7KlYam0tBUGppKQ1NpaCoNTaWhqTQ0lYam0tBUGppKQ9NoaBoNTaOhaTQ0jYamcV5qnJca56XGealxXmqclxrnpcZ5qXFeamwvjO2Fsb0wthfG9sLYXhjbC2N7YWwvjO1FJTQ1UYgoioaFeWpYmKeGhXlqWJinhhuMqeEGY2q4wZgaFuapYWGeVkLzohGd2Jeb6E1oFqIoGhbmqWFhnhoW5qlhYZ4abjCmhhuMqeEGY2o0NI2GptHQNBqaRkPTaGgaDU2joWk0NI2GptHQNBqaRkPTOC81zkuN81LjvNQ4LzXOS43zUuO81DgvNc5LjfNS47zUOC81zkuN7YWxvTC2F8b2wtheZIwzK2TGOIs26HTVtN6Zp5njLDKQg7ouZo6zaIIWqOti5jiLBKSgrovWO/PUemeeZo6zaIIWqK430QxxFnVd9N6Zp5ngLHJQ/03qvTNPM71ZtEAb1HUxk5tFCjKQV9X03pmnGdosmqAFqutNNAObRV0XM65ZZCAH9Qwzo5pFE9R1MXOaRQckIK2qmRnNrJUZ0SzCBPMmNAsnEUXxJjQLD1GImGDehGahEzHBvAnNwknEBPMmNAsPEUXRsTBPK6F50Yn4u9RpaDoNTaeh6TQ0nYam09B0GppOQ9NpaDoNTaeh6TQ0nYam09B0GppOQ9NpaDoNTee81Dkvdc5LnfNS57zUOS91zkud81LnvNTZXjjbC2d74WwvnO2Fs71wthfO9sLZXjjbi0po5jMfTkRRDCzM08DCPA0szNPAwjwN3GBMAzcY08ANxjSwME8DC/O0EpqJcxAnsS830ZvQLERRDCzM08DCPA0szNPAwjwN3GBMAzcY08ANxjRoaAYNzaChGTQ0g4Zm0NAMGppBQzNoaAYNzaChGTQ0g4ZmcF4anJcG56XBeWlwXhqclwbnpcF5aXBeGpyXBuelwXlpcF4anJcG24tgexFsL4LtRbC9yBhnVsiMcRYpyLpqRu/M08xxXtIBmqCui5njLDogAXVdzBxnkYPaq43emafRO/M0emeeZo6z6IAEVNebaIY4i7ouRu/M00xwFk3QAnVdzPRmkYAU1HUxk5tF7dVmbrNoVtWM3pmnGdosOiAB1fUmmoHNoq6LGdf8yDKtWTRBNcO0jGoWHVDVRcucZpGBHBS3alpmNL9aaRnRLOoJpt2EZuEhdlG0m9AsNKITe4JpN6FZOIk9wbSb0Cw8xJ5g2k1oFhqxi6INLMyzSmhenMRF7LdyGzA0bcDQtAFD0wYMTRswNG3A0LQBQ9MGDE0bMDRtHKodqh2qHaodqh2qHaoJ1YRqQjWhmlBNqCZUE6oJ1YRqSjWlmlJNqaZUU6op1ZRqSjWlmvXlJlYJzYtdFG1gYZ4NLMyzgYV5NrAwzwZuMGYDNxizgRuM2cDCPBtYmGeV0Ly4iYfYl5vYTWgWdlG0gYV5NrAwzwYW5tnAwjwbuMGYDdxgzAZuMGYDhqYNGJo2YGjagKFpA4amTRiaNmFo2oShaROGpk0YmjZhaNqEoWkThqZNzEttDqpNqk2qTapNqk2qTapNqk2qTapNqi2qLaotqi2qLaotqi2qrZphWsY4i6Lp7q7YiVUXLXOcRRt0QFUXLXOcRQZyUNVFyxxn0QQtUNVFm70zz2bvzLPMcRYZyEF1vYlliLOo6qLN3plnmeAsOiABVV20TG8WOSiaemeeZXKzaIE26NyqabN35lmGNosM5KC63sQysFnUdTHjmkUbdEA1w7SMahYZqOti5jQv+QBN0KqqmRnNrJUZ0SzqCabdhGahEVEUb0LzYgziJPYE025Cs/AQe4JpN6FZaMSeYNpNaCbehGYhiuLCwjyrhObFQxQi3soXDE1bMDRtwdC0BUPTFgxNWzA0bcHQtAVD0xYMTVuTapNqk2qTaotqi2qLaotqi2qLaotqi2qLaotqm2qbaptqbC8W24vF9mKxvVhsLxbbi8X2YrG9WGwvFtuLSmhq4iGiKC4szLOFhXm2sDDPFhbm2cINxmzhBmO2cIMxW1iYZwsL86wSmheVaMS+3MRuQvMiFubZwsI8W1iYZwsL82xhYZ4t3GDMFm4wZgs3GLMFQ9MWDE1bMDRtwdC0BUPTFgxNWzA0bcHQtAVD0xYMTVtGNaOaU82p5lRzqjnVnGpONaeaU82pFlQLqgXVgmpBNbYXi+3FYnux2F4sthcZ48wKmTHOogXaXTV378yzzHEWKchAXRczx3lpDtAEdV3MHGfRAQmo6+LunXm2e2eeZY7z0hqgCarrTSxDnEVdF3fvzLNMcBYZyEFdFzO9WTRBC9R1MZObRQJSkFXV3L0zzzK0eekM0ATV9SaWgc2irosZ1yxSkIFqhmkZ1bwkA9R1MXOaRRt0QFJVMzOaWSszolnUE0y7Cc2LOogoijehWbiJh9gTTLsJzUIj9gTTbkLzog1iTzDtJjQLNxFFcWNhnlVC86IRnYi38g1D0zYMTdswNG3D0LQNQ9M2DE3bMDRtw9C0DUPTtlMtqBZUC6oF1YJqQbWgWlAtqIZ5qR3MS+1gXmoH81I7mJfawbzUDualdtheHLYXh+3FYXtx2F4ctheH7cVhe3HYXhy2F5XQ1EQjoigeLMyzg4V5drAwzw4W5tnBDcbs4AZjdnCDMTtYmGcHC/OsEpoXA7gHsS83sZvQLERRPFiYZwcL8+xgYZ4dLMyzgxuM2cENxuzgBmN2YGjagaFpB4amHRiadmBo2oGhaQeGph0YmnZgaNqBoWlHqCZUE6oJ1YRqQjWhmlBNqKZUU6op1ZRqSjWlmlJNqcb24rC9OGwvDtuLw/YiY5xZITPGWSQg7ap5emeeZY6zKJp8gLouZo6zaIMOqOti5jiLDOSground+bZ6Z15ljnOog06oLrexDLEWdR18fTOPMsEZ1IGOIsmqOtipjeLDkhAXRczuVnkoGhKj3MmdV3M0GbRBh1QXW9iGdgs6rqYcc2i9mozrFlUM0zLqGbRBnVdzJxmkYIM5FU1M6OZtTIjmkU9wbSb0CzcRBTFm9AsVKIRe4JpN6F58QxiTzDtJjQLN7EnmHYTmoVKRFEULMyzSmgmyiBOIt7KhYam0NAUGppCQ1NoaAoNTaGhKTQ0hYam0NAUGppCQ1NoaAoNTaGhKTQ0hYamGNWMakY1o5pRzahmVDOqGdXYXgjbC2F7IWwvhO2FsL0QthfC9kLYXgjbi0po5jMfg4iiKFiYZ4KFeSZYmGeChXkmuMGYCW4wZoIbjJlgYZ4pFuZZJTQvLuIm9uUmdhOahSiKioV5pliYZ4qFeaZYmGeKG4yZ4gZjprjBmCkNTaWhqTQ0lYam0tBUGppKQ1NpaCoNTaWhqTQ0lYam0tDURbVFtUW1TbVNtU21TbVNtU21TbVNtU21TbVDNbYXyvZC2V4o2wtle5ExzqyQGeMsclB01dTemWeZ4yxaoA3qupg5ziIFGajrYuY4L+kATVDXRe2deaa9M88yx1mkIAPV9SaWIc5LvTPPtHfmWSY4izbogLouZnqzyEAO6rqYyc2iCVqgXVVTe2eeZWizSEEGqutNLAObl3pnnmVcs2iBNqhnmBnVLFJQ18XMaRa1V5spzaJZVTMzmlkrM6JZhAnmTWgWKhFF8SY0C2HW3oRmISaYN6FZuImYYN6EZqESMcG8Cc1CmLWGhXlmWJhnldC8uImHiLdyo6FpNDSNhqbR0DQamkZD02hoGg1No6FpNDSNhqbR0DQamkZD02hoGg1No6FpnJca56XGealxXmqclxrnpcZ5qXFeapyXGtsLY3thbC+M7YWxvTC2F8b2wtheGNsLY3tRCc185nUTURQNC/PMsDDPDAvzzLAwzww3GDPDDcbMcIMxMyzMM8PCPKuE5kUhKrEvN7Gb0CxEUTQszDPDwjwzLMwzw8I8M9xgzAw3GDPDDcbMaGgaDU2joWk0NI2GptHQNBqaRkPTaGgaDU2joWk0NI2GpnNe6pyXOuelznmpc17qnJc656XOealzXuqclzrnpc55qXNe6pyXOtsLZ3vhbC+c7YWzvcgYZ1bIjHEWTdDqqum9M88yx1kkIAV1XcwcZ1F7tZnjLOq6mDnOog06oK6L3jvzzHtnnmWOs6j/JvW+t5hlijNrZYY4i7oueu/Ms0xwFinIQF0XM715SQZogrouZnKz6IAEpFU1vXfmWYY2i9qrzchmUV1vYhnYLOq6mHHNIgEpqGeYGdUsaq/We2eeZU6zaIE26FTVzIxm1sqMaBZhgnkTmoUwax0L8+wmNAsXcRMxwbwJzUIlYoJ5E5qFMGtvQjPr401oFi4iiqJjYZ5VQvOiEo2It3KnoRk0NIOGZtDQDBqaQUMzaGgGDc2goRk0NIOGZtDQDBqaQUMzaGgGDc2goRmclwbnpcF5aXBeGpyXBuelwXlpcF4anJcG24tgexFsL4LtRbC9CLYXwfYi2F4E24tge1EJTU1UIopiYGGeBRbmWWBhngUW5lngBmMWuMGYBW4wZoGFeRZYmGeV0LzoRPxdehOaWSpvQrMQRTGwMM8CC/MssDDPAgvzLHCDMQvcYMwCNxizoKEZNDSDhmbQ0AwamkFDM2hoBg3NoKEZNDSDhmbQ0AwamsF5aXBeGpyXBuelwXlpcF4anJcG56XBeWlwXhqclwbnpcF5aXBeGmwvgu1FsL0IthfB9iJjnFkhM8ZZdEDSVTN6Z55ljrPIQeXV+uideZ45zqIF2qCqi545ziIFGajqoo/emeejd+Z55jiLFmiD6noTzxBnUdVFH70zzzPBWRRNa4CqLnqmN4s26ICqLnomN4sM5KC4VdNH78zzDG0WLdAG1fUmnoHNoqqLnnHNIgdF06kZpmdUs2iBqi565jSLBKQgu1XTM6MZ+XOcaJKeYPpNaBYuYhdFvwnNQiEqsSeYfhOahQHUnmD6TWgWLmJPMP0mNAuF2EXRBxbmeSU0LwbQBrHfyn3A0PQBQ9MHDE0fMDR9wND0AUPTBwxNHzA0fcDQ9OFUc6o51ZxqTjWnmlPNqeZUC6oF1YJqQbWgWlAtqBZUC6qhvfCJ9sIn2gufaC98or3wifbCJ9oLn2gvfKK98EpoamIAsTDPJxbm/eAibuIhClGJRuyi6BML87wSmhcncRH7chO/Cc3CLoo+sTDPJxbm+cTCPJ9YmOcTNxjziRuM+cQNxnzC0PQJQ9MnDE2fMDR9wtD0CUPTJwxNnzA0fcLQ9AlD0+eh2qHaodqh2qHaodqhmlBNqCZUE6oJ1YRqQjWhmlBNqKZUU6op1ZRqSjWtGaZnjLPIQF5V02fvzPPMcRZN0AJ1XcwcZ5GAFNR1MXOcRdHkA9R1cfbOPJ+9M88zx1kkIAXV9SaeIc6irouzd+Z5JjiLFmiDui5merNIQQbqupjJzaQMbhZN0KqquXpnnmdos0hACqrrTTwDm0VdFzOuWTRBC1QzTM+oZpGAui5mTrPIQdGUc1JPqutNPCOaRT3B9JvQLBQiiuJNaBY6MYC7J5h+E5qFi9gTTL8JzUIh9gTTb0Kz0IkoigsL87wSmhcXcRPxVr5gaPqCoekLhqYvGJq+YGj6gqHpC4amLxiavmBo+hKqCdWEakI1oZpQTammVFOqKdWUako1pZpSTammVDOqsb1YbC8W24vF9mKxvVhsLxbbi8X2YrG9WGwvKqGZz7wvIoriwsI8X1iY5wsL83xhYZ4v3GDMF24w5gs3GPOFhXm+sDDPK6F58RCF2Jeb+E1oFqIoLizM842Feb6xMM83Fub5xg3GfOMGY75xgzHfMDR9w9D0DUPTNwxN3zA0fcPQ9A1D0zcMTd8wNH3D0PQ9qTapNqk2qbaotqi2qLaotqi2qLaotqi2qLaotqm2qbapxvZis73YbC8224vN9iJjnFkhM8Z56QzQ7Kq5e2eeZ46z6IAE1HUxc5xFDoqm3pnnmeMsWqAN6rq4e2ee796Z55njLHJQ/02aKc6slRniLOq6uHtnnmeCs0hACuq6mOnNomiyAeq6mMnNog06IKmquXtnnmdos8hB0eR1vYlnYLOo62LGNYsOSEA1w/SMahY5qOti5jSLJmiBdlXNzGhmrcyIZlFPMP0mNAudiKJ4E5qFk7iIPcH0m9AsFGJPMP0mNAud2BNMvwnNwklEUTxYmOeV0LwoRCXirfzA0PQDQ9MPDE0/MDT9wND0A0PTDwxNPzA0/cDQ9LOotqi2qLaptqm2qbaptqm2qbaptqm2qbapdqh2qHaodqjG9uKwvThsLw7bi8P24rC9OGwvDtuLw/bisL2ohGY+8yJEFMWDhXl+sDDPDxbm+cHCPD+4wZgf3GDMD24w5gcL8/xgYZ5XQvOiEZ3Yl5v4TWgWoigeLMzzg4V5frAwzw8W5vnBDcb84AZjfnCDMT8wNP3A0PQDQ9MPDE0/MDT9wND0A0PTDwxNPzA0/cDQ9ONUC6oF1YJqQbWgWlAtqBZUC6phXuqCeakL5qUumJe6YF7qgnmpC+alLmwvhO2FsL0QthfC9iJjnFkhM8ZZtEGnq6b0zjzPHGeRgRzUdTFznEUTtEBdFzPHWSQgBXVdlN6Z59I78zxznEUTtEB1vYlniLOo66L0zjzPBGeRg/pvUumdeZ7pzaIF2qCui5ncLFKQgbyqpvTOPM/QZtEELVBdb+IZ2CzquphxzSIDOahmmJ5RzaIJ6rqYOc2iAxKQVtXMjGbWyoxoFvUE029Cs3ASURRvQrPwEIXYE0y/Cc1CJ/YE029Cs3ASe4LpN6FZeIgoioKFeV4JzYtOxN+lQkNTaGgKDU2hoSk0NIWGptDQFBqaQkNTaGgqDU2loak0NJWGptLQVBqaSkNTaWgq5qWug2qTapNqk2qTapNqk2qTamwvlO2Fsr1QthfK9kLZXijbC2V7oWwvlO1FJTQ10YkoioqFea5YmOeKhXmuWJjnihuMueIGY664wZgrFua5YmGeV0Iz8QziJPblJn4TmoUoioqFea5YmOeKhXmuWJjnihuMueIGY664wZgrDU2loak0NJWGptLQVBqaSkNTaWgqDU2loak0NJWGptLQVKWaUk2pplRTqhnVjGpGNaOaUc2oZlQzqhnV2F4o2wtle6FsL5TtRcY4s0JmjLNIQdZVU3tnnmeO81IM0AR1XcwcZ9EBCajrYuY4ixzUXq31zjy33pnn1jvzPHOcRQckoLrexDPEWdR10XpnnmeCs2iCFqjrYqY3iwSkoK6Lmdwsaq82c5tFs6qm9c48z9Bm0QEJqK438QxsFnVdzLjmpT1AE9QzzIxqFh1Q18XMaRYZyEFRVTMzmlkrM6JZhAnmTWgWHiKK4k1oFhrRiZhg3oRm4SRignkTmoWHiAnmTWgWGhFF0bAwzyuheXESFxFv5UZD02hoGg1No6FpNDSNhqbR0DQamkZD02hoGg1No6FpNDSNhqbR0DQamkZD0zgvNc5LjfNS47zUOC81zkuN81LjvNQ4LzW2F8b2wtheGNsLY3thbC+M7YWxvTC2F8b2ohKamjiJKIqOhXnuWJjnjoV57liY544bjLnjBmPuuMGYOxbmuWNhnldC8+ImHmJfbuI3oVmIouhYmOeOhXnuWJjnjoV57rjBmDtuMOaOG4y509B0GppOQ9NpaDoNTaeh6TQ0nYam09B0GppOQ9NpaDoNTee81Dkvdc5LnfNS57zUOS91zkud81LnvNQ5L3XOS53zUue81DkvdbYXzvbC2V442wtne5ExzqyQGeMsaq/2bt7Mqum9M88zx1m0QQfUdTFznEUGclDXxcxxFk3QAnVd9N6Z59478zxznEUGclBdb+IZ4izquui9M88zwVl0QALqupjpzSIHtVfrvTPPM7lZtEAbdKpqeu/M8wxtFhnIQXW9iWdgs6jrYsY1izbogHqGmVHNIgN1Xcyc5qU5QBO0qmpmRjNrZUY0izDBvAnNQiOiKN6E5sU1iJOICeZNaBYeIiaYN6FZaERMMG9C8+IeRBTFwMI8r4TmxUMUIt7Kg4Zm0NAMGppBQzNoaAYNzaChWQnNi0KkGg3NoKEZNDSDhmbQ0AwamkFDMzgvDc5Lg/PS4Lw0OC8NzkuD89LgvDQ4Lw22F8H2ItheBNuLYHsRbC+C7UWwvQi2F8H2ohKa+czbIaIoBhbmeWBhngcW5nlgYZ4HbjDmgRuMeeAGYx5YmOeBhXleCc2LSjRiX27iN6F5EQvzPLAwzwML8zywMM8DC/M8cIMxD9xgzAM3GPOgoRkwNGPA0IwBQzMGDM0YMDRjwNCMAUMzBgzNGDA0Y8DQjDGoNqk2qTapNqk2qTapNqk2qTapNqm2qLaotqi2qLaotqi2qLaotqi2qLZrhhkZ4yxaoF1VM0bvzIvMcRYpyEBVFyNznJfOAE1Q1cXIHGfRAQmo6mKM3pkXo3fmReY4L8kATVBdbxIZ4iyquhijd+ZFJjiLDOSgqouR6c2iCVqgqouRyc0iASnIbtWM0TvzIkObl2yAJqiuN4kMbBZVXYyMaxYpyEA1w4yMal7yAaq6GJnTLNqgA5JbNSMzmpE/hxuoJ5hxE5oXYxC7KMZNaBZu4iH2BDNuQrPQiD3BjJvQTLwJzcKeYMZNaBZuYhfFmFiYF5XQvGhEJ/ZbeUwYmjFhaP7gIm7iIQpRiUZ0ItUW1RbVFtUW1RbVFtUW1RbVFtUW1TbVNtU21TbVNtU21TbVNtU21TbVDtUO1Q7VDtUO1Q7VTl9uEpXQvNhFMSYW5sXEwryYWJgXEwvzYuIGYzFxg7GYuMFYTCzMi4mFeVEJzYsB1EHsy03iJjQLuyjGxMK8mFiYFxML82JiYV5M3GAsJm4wFhM3GIsJQzMmDM2YMDRjwtCMCUMzJgzNmDA0Y8LQjAlDMyYMzZhONaeaU82p5lRzqjnVnGpOtaBaUC2oFlQLqgXVgmpBtaAa24vF9mKxvVhsLzLGmRUyY5xFAtKumqt35kXmOIuiaQ5Q18XMcRZt0AF1XcwcZ5GBHNR1cfXOvFi9My8yx1m0QQdU15tEhjiLui6u3pkXmeC8tAdogrouZnqz6IAE1HUxk5tFDoqm9DhnUtfFDG0WbdAB1fUmkYHNoq6LGdcsiiYZoJphRkY1izao62LmNIsUZCCvqpkZzayVGdEs6glm3IRm4SaiKN6EZqESjdgTzLgJzYs2iD3BjJvQLNzEnmDGTWgWKhFFcWFhXlRCM9EHcRLxVr5gaMaCoRkLhmYsGJqxYGjGgqEZC4ZmLBiasWBoxgqqBdWCakG1oFpQLagGQzM25qWxMS+NjXlpbMxLY2NeGhvz0tiYl8bGvDQ25qWx2V5stheb7cVme7HZXmy2F5vtxWZ7sdlebLYXldD8nvlKaF5EUdxYmBcbC/NiY2FebCzMi40bjMXGDcZi4wZjsbEwLzYW5kUlNC8u4ib25SZxE5qFKIobC/NiY2FebCzMi42FebFxg7HYuMFYbNxgLDYMzdgwNGPD0IwNQzM2DM3YMDRjw9CMDUMzNgzN2DA0YwvVhGpCNaGaUE2oplRTqinVlGpKNaWaUk2pplRTqhnV2F5stheb7cVme7HZXmSMMytkxjiLHBRdNXfvzIvMcRYt0AZ1XcwcZ5GCDNR1MXOcl2KAJqjr4u6debF7Z15kjrNIQQaq600iQ5xJp3fmxemdeZEJzqINOqCui5neLDKQg7ouZnKzaIIWaFfVPL0zLzK0WaQgA9X1JpGBzUu9My8yrlm0QBtUM8zIqGaRgrouZk6zKJr2AM2qmpnRzFqZEc2inmDGTWgWKhFF8SY0CwN4BrEnmHETmoWb2BPMuAnNQiX2BDNuQrMwgFiYFwcL86ISmhc38RDxVn5gaMaBoRkHhmYcGJpxYGjGgaEZB4ZmHBiacWBoxlGqKdWUako1pZpRzahmVDOqGdWMakY1o5pRzajmVHOqsb04bC8O24vD9uKwvThsLw7bi8P24rC9OGwvKqGZz3xsIoriwcK8OFiYFwcL8+JgYV4c3GAsBDcYC8ENxkKwMC8EC/OiEpoXhajEvtwkbkKzEEVRsDAvBAvzQrAwLwQL80Jwg7EQ3GAsBDcYC6GhKTQ0hYam0NAUGppCQ1NoaAoNTaGhKTQ0hYam0NAUGpqyqbaptqm2qbaptqm2qbaptqm2qXaodqh2qHaoxvZC2F4I2wtheyFsLzLGmRUyY5xFE7S6akrvzIvMcRYJSEFdFzPHWdRebeY4i7ouZo6zaIMOqOui9M68kN6ZF5njLOq/SaXvLRaZ4sxamSHOoq6L0jvzIhOcRQoyUNfFTG9e8gGaoK6LmdwsOiABaVVN6Z15kaHNovZqM7JZVNebRAY2i7ouZlyzSEAKqhlmZFSzqL1a7Z15kTnNogXaoFNVMzOaWSszolnUE8y4Cc1CmLWKhXlxE5qFi7iJPcGMm9AsVGJPMOMmNAth1t6EZtbHm9AsXEQURcXCvKiE5kUlGhFv5UpDU2loKg1NpaGpNDSVhqbS0FQamkpDU2loKg1NpaGpNDSVhqbS0FQamkpDUw/VDtUO1Q7VhGpCNaGaUE2oxvZC2V4o2wtle6FsL5TthbK9ULYXyvZC2V5UQjOfeVUiiqJiYV4oFuaFYmFeKBbmheIGY6G4wVgobjAWioV5oViYF5XQvOhE/F16E5pZKm9CsxBFUbEwLxQL80KxMC8UC/NCcYOxUNxgLBQ3GAuloak0NJWGptLQVBqaSkNTaWgqDU2loak0NI2GptHQNBqaxnmpcV5qnJca56XGealxXmqclxrnpcZ5qXFeapyXGuelxnmpcV5qbC+M7YWxvTC2F8b2ImOcWSEzxll0QNJV03pnXmSOs8hB7dVa78yLzHEWLdAGdV3MHGeRggzUddF6Z15Y78yLzHEWLdAG1fUmkSHOoq6L1jvzIhOcRe3VZn6zqOtipjeLNuiAui5mcrPIQA6KqprWO/MiQ5tFC7RBdb1JZGCzqOtixjWLHNRebWY1s0JmVLNogbouZk6zSEAKsqqamdHMWpkRzUuOCeZNaBYuIoriTWgWClGJmGDehGYhzNqb0Mz6eBOahYuICeZNaBYKEUXRsDAvKqF5EWZtJTQv4q3caWg6DU2noek0NJ2GptPQdBqaTkPTaWg6DU2noek0NJ2GptPQdBqaTkPTaWg656XOealzXuqclzrnpc55qXNe6pyXOuelzvbC2V442wtne+FsL5zthbO9cLYXzvbC2V5UQlMTYdY6FuaFY2FeOBbmhWNhXjgW5oXjBmPhuMFYOG4wFo6FeeFYmBeV0Lw4iYvYl5vETWgWoig6FuaFY2FeOBbmhWNhXjhuMBaOG4yF4wZj4TQ0nYam09B0GppOQ9NpaDoNTaeh6TQ0nYam09B0GppOQ9M5L3XOS53zUue81Dkvdc5LnfNS57zUOS91zkud81LnvNQ5L3XOS53thbO9cLYXzvbC2V5kjDMrZMY4iwzkXTW9d+ZF5jiLJmiBui5mjrNIQArqupg5zqL2ajPHWdR1MXpnXkTvzIvMcRYJSEF1vUlkiLOo62L0zrzIBGfRAm1Q18VMbxYpyEBdFzO5eWkP0AStqprRO/MiQ5tFAlJQXW8SGdgs6rqYcc2iCVqgnmFmVLNIQF0XM6dZ5KD2ajOkmVUzM5pZKzOiWYQJ5k1oFgoRRfEmNAudCLP2JjSzPt6EZuEiYoJ5E5qFQsQE8yY0C52IohhYmBeV0Ly4iJuIt/KgoRk0NIOGZtDQDBqaQUMzaGgGDc2goRk0NIOGZtDQDBqaQUMzaGgGDc2goRmclwbnpcF5aXBeGpyXBuelwXlpYF7680RjYPrxfHg9vB8+D8vD+rA97A8/uvPRnX3pycfr4S6RH5+H5WF92B72h4OMu4593KXy4/Xwfvg8LA/3lSgf28NdMT8OMvbpfTwfXg/vh8/D8nBXl4/tYX84yHA+P54Pr4f3w+dhefjRPY/ueXTPoyuPrjy68ujKoyuPrjy68ujKoyuPrjy6+ujqo6uPrj66+ujqo6uPrj66WoPQDwNogzir+n5cBfbDTTxEIVaR/dCITgxgL+H7cBIXcROr2H4oRCUa0YkBjLqU5cNJrKL74SYeohCVWJX3QydGYwZEG6v6friIm3iIcuvzh1WCPzSiEwM46/KWDyexCvGHm3iIQqzB6YdGdGLV4x9cgziJi7hvxf6wLnb5UIg9QP3YHvaHuyz/8B4Pz4fXwz1H/fg8LA/3KPVje9gf7mnqD5/x8Hy4a/TH++HzsDysD7OszOMPs6xMGQ/Ph9fD++HzsDysDz+68ujKo6uPrj66+ujqo6uPrj66+ujqo6uPrj669ujao2uPrj269ujao2uPrj269ujao+uPrj+6/uj6o+t9nczH8jDL93R72B9m+Z4xHp4Pr4f3wyzfM+Rhfdge9of7spmfF8oYD7N8r7Ee3g+fh+Vhfdge9odZztYcD8+H18P74fOwPKwP28P+8KO7Ht316K5Hdz2669Fdj+56dNejux7d9ejuR3c/uvvR3Y/ufnT3o/u0Setpk9bTJq2nTVpPm5TB1VvMM7nauIkHJX4dVPCMrzYa0Ymo4BlhbZzERUQFzxhroxCViAq+xImo4BlmbZzERdxd1zPN2ogKvlSJRnRiAA0VPNOsjYu4iajgmWZtVKIRvUv8MlTwTLM2TuIi7q7rmWZtRAXPNGujEZ0YXcwzzdo4iajgmWZtPEQhapf4TLPeup5p1sae9v7U3jEeng+zfN9Ea/N5WB7uoe/H9rA/3HPfH57j4flwj34/3g+fh1m+99SH7WF/OMiLZWWv+fB6eD98HpaH9WF72B9mOdv70d2P7n5096O7H9396O5Hdz+6+9Hdj+55dM+jex7d8+ieR/c8uufRfdqk/bRJ+2mT9tMm7adN2k+btJ82aT9t0n7apP20SZWDvb8n4g+zfG8dD8+H18P74fOwPKwPs3xv9YeDbOPh+XBf4/Pxfpjle5s8rA/bw/4w/+rfPh6eD7Ocbd8Pn4flYX3YHvaHWc52jIfnw49uPLrx6MajG49uPLrx6AZ1zxgPz4fXw/vh87A8rA/bw/7wo/u0Sedpk87TJp2nTcqU7S3mGbNtVKKhxJ+JCp5Z28I1iJOICp5528ZDFCIqeGZuG50YwI0KfvYkLuImHqIQtet6Rm8bUcHPRgXP6G3jJC4iKnhGbxuFqERU8IzeNgZQBnF2iT+CCp7R28ZDFKJ2Xc/obSMqeEZvC3UQJ3F1Mc/obeMhooJn9LbRiE6MLvEZvb11PaO3jT2a/ng/fB5m+b7x22Z72B/uCfUP+3h4PtxD6o/3w+fhnlN/rA/bwyzfx1m+K4xbPB9eD7OsnDgPy8P6sD3sD7OcyWNiy2Niy2Niy2Niy2Niy2Niy2Niy2Niy2Niy2Niy2Niy3x056M7H9356M5Hdz6689Gdj+58dJ82SZ42SZ42SZ42SZ42SZ42SZ42SZ42SZ42SZ42qUK7enk+zPItez98HpaH9WF72B9m2yCH5VvOfHg9vB8+D/cFSR/rwyzfcvxhlm+R8fB8eD28Hz4Ps5zJY2LLY2LLY2LLY2LLY2LLY2LLY2LLY2LLY2LLY2LLY2LLY2KLPrr66Nqja4+uPbr26Nqja4+uPbr26Nqja4+uP7r+6D5tkjxtkjxtkjxtkjxtUkaCbzHPTHAjPPu7yPWWeAlU8AwGN27iIaKCZzi40YhORAXPgHDjJC4iKriOQxSiEo3oxOi6njnhRlRwnYu4iYcoRFTwzAk3OhGevS5U8MwJNy7iJp4u8bpQwTMn3GhEJ0bX9cwJN6KCZ064cRMPUbqYZ0640Yio4JkTLjyDOImrS3zmhG9dz5xwY8/RP9aH7WGW75sVLpbx8Hy4x+kf74fPwz1R/1gftod7qP4xTfsbG25m+VZdD++Hz8PyMMuKPia2Pia2Pia2Pia2Pia2Pia2Pia2Pia2Pia2Pia2Pia2Pia2Pia2Pia2Pia2Pia2Pia2+qPrj64/uv7o+qPrj248uvHoxqP7tEn6tEn6tEn6tEn6tEn6tEn6tEn2tEn2tEn2tEmVMNbL52GWbxv6sD3sD7N82xwPz4fXwyzfNs/D8rA+bA/31VMf07S3xfJtaz68Ht4Pn4flYX3YHmY5s8fEtsfEtsfEtsfEtsfEtsfEtsfEtsfEtsfEtsfEtsfEtsfEtmfWb8+s355Zvz2zfntm/fbM+u2Z9dsz67dn1m/PrN+eWb89s357Zv32zPrtaZPsaZPsaZPsaZPsaZMyv3yLeQaYGxdxo8SbooJnirlRiUZEBc8kc6EN4iSigmeaufEQhYgKbmZEJ8Kzz1Bz4ySurusZam5EBTcXohKN6ERU8Aw1N07iIqKCZ6i5UYhKtC7xFqjgGWq+mKHmxklcXdcz1NyICp6h5kYlGhFT9ww1F85BRAXPUHPjJh6idInPUPOt6xlqbuTM/aaai9d4mOX7Bpub98PnYc7cb7i52R7mzP3mm4v3eJgz9xtxbt4Ps3z7lof1YXvYH2ZZ8cfE9sfE9sfE9sfE9sfE9sfE9sfE9sfE9sfE9sfE9sfE9sfE9sfE9sfE9sfE9sfE9sfE9mfW78+s359Zvz+zfn9m/f7M+v2Z9fsz6/dn1u9Pm+RPm+RPm+RPm+RPm+RPm+RPm+RPm+RPm+RPm1Rx6Pt7YvYwy7cby7f7eHg+vB7eD5+H5WGWb3d72B+maV/h6OK+1Ovj9TDLt8d5WB7Wh+1hf5h/9ccYD7OcxWNix2Nix2Nix2Nix2Nix2Nix2Nix2Nix2Nix2Nix2Nix2NixzPrj2fWH8+sP55Zfzyz/nhm/fHM+uOZ9ccz649n1h/PrD+eWX88s/54Zv3xtEnxtEnxtEnxtEnxtEkZtr7FPNPWjUJUlPjYqOAZuW6EZ5+h60ZU8IxdN27iIaKCZ/S60YhORAUPGcRJXMRNPETpup4J7EZU8BAnwrPPBHbjJKKCZwK78RCFiAqeCexGJ8KzzwT2LfFhqOCZwG7cxEOUruuZwG5EBc8EdiM8+0xgN2Lqngnsxk1EBc8EdqMSjehd4jOBfet6JrAbOXO/Eezm/TDL901hN+vD9jBn7jeJnTxvErsZM/d5k9jN+2HM3OdNYjfrwyjfc2BD5sdBnuPh+TDKyhw0seegiT0HTew5aGLPQRN7DprYc9DEnoMm9hw0sedYj+56dNejux7d9eiuR3c9uuvR3Y/ufnT3o7sf3f3o7kd3P7r70d2P7n50z6N7Ht3z6J5H9zy659E9j+55dM+je/pCtDkriV2M8j0Html+vB8+D8vD+rA97A+jfM+BrZofz4fXw/vhvi7tY3kY5XsOLNf82B8OMvZrfjwfXg/vh1HO5qCJPQdN7DloYs9BE3sOmthz0MSegyb2HDSx56CJPYc/uv7o+qPrj64/uv7oxqMbj248uvHoxqMbj248uvHoxqPLWf+cnPXPyTbpe7E9vB8+D8vDPXWfGddudGJ0if/+oyr4zLx24yJuYlfwmXntRiUasSv4zLx24RrESewKPmfv5fzwEIWoRCPWhW0fBrDXc344iYu4iYfYFXxmSrvRiE7sCj4zod04iYu4q8TP2cs6PxSiEo1YF7t9GMBe2fnhJC7iJvbUfWYku1GJXcFn5rEbA6iDOKvEz8xix/3ZdBMxc583id2sD6N8z5vEbg6yjYcxc583id28H8bMfd4kdrM+jJn7vEns5iA7y/f0+fB6eD98HmZZmTSx56SJPSdN7DlpYs9JE3tOmthz0sSekyb2nDSx54xHNx7deHTj0aWJPRdN7LloYs9FE3suzvrn4qx/Ls765+Ksfy7O+ufirH+u8ejOR3c+uk+btJ42aT1t0nrapPW0Setpk9bTJq2nTVpPm7SeNqmS2Hp5P8zyvZY8rA/bw/5wkHG/xI/nwyzfa++Hz8PysD6MC+XmTWI3s3yvMx6eD6+H98PnYXlYH2Y5WzSx56KJPRdN7LloYs9FE3sumthz0cSeiyb2XDSx55JHVx5deXT10dVHVx9dfXT10dVHVx9dfXT10dVH1x5de3Tt0bVH92mT1tMmradNWk+btJ42KePat5hnXLtxEhdK/HJU8MxrNwpRiajgmdduDGAMIip45rUbN/EQUcFXKNGITuy/+OfuGy5+2FfKzQxrN6KC73GIQlSiEVHBM6VdOAdxElHBM6HdeIhC1C7xe6KCZzi7MYBrEPtKuZnB7EZU8IxlNwpRiT11nxnJbgzgRgXPPHbjIm7i6RKfWexb1zOK3YiZ+7xJ7OYgH5bvm8RuXg/vhzFznzeJ3awPY+Y+bxK7OciCmfu8Sezm9TDL95bzsDysD9vDLCubJvbcNLHnpok9N03suWliz00Te26a2HPTxJ6bJvbc+ujqo2uPrj269ujao2uPrj269ujao2uPrj26/uj6o+uPrj+6/ug+bdJ+2qT9tEn7aZP20ybtp03aT5u0nzZpP23SftqkSmLf35PQh1m+d/jDLN9njIfnw+vh/fB5mOX7DH3YHvaH+Vf/TWLfsn6T2M0s32fuh8/D8rA+bA/7w2wbDk3seWhiz0MTex6a2PPQxJ6HJvY8NLHnoYk9D03seWhiz7Mf3f3o7kd3P7r70d2P7n5096O7H9396J5H9zy659E9j+55dM+jex7dp006T5t0njbpPG3SedqkjGvfYp5x7cZDFJT4I6jgmddudGIAFRU889qNi7iJqOCZ125UohFRwY+igh8bxElcxE3sK+VmhrUbUcGPGdGJAfRBRAXPlHbjJh4iKngmtBuN6MToEn8CFTzD2Y2LuIl9pdzMYHYjKnjGshud2J79zEz2LeYZyW5cRFTwzGM3ClGJ1iU+s9i3rmcUu3Bi5j5vErt5PczyfZPYzfKwPoyZ+7xJ7GaW75vEbp4Ps3zfJHbzeZjlW5Y+bA/7wzTt5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5TGx5Ty68ujKoyuPrjy68ujKoyuPrjy6T5skT5skT5skT5skT5skT5skT5skT5skT5tUSez7e6L+MMu32Hh4Prwe3g+fh+VhfZjlW8wfZvmuJHbxfBgz93mT2M0s3zeJ3awP28P+MMu3xHh4PsxyJo+JLY+JLY+JLY+JLY+JLY+JLY+JrY+JrY+JrY+JrY+JrY+JrY+JrZz1T+Wsfypn/VPHozsf3fnozkd3Prrz0Z2P7nx056M7H9356D5tkj5tkj5tkj5t0t3qfKv2Xeu85LI+bA/7w0G+64+K58Pr4f3wefjR3Y/ufnT3o7sf3fPonkf3PLrn0T2P7nl0z6N7Ht3z6J5HVx5deXTl0ZVHVx5deXTl0ZVHVx5deXT10dVHVx9dfXT10dVHVx9dfXT10dVH1x5de3Tt0bVH1x5de3Tt0bVH1x5de3T90fVH1x9df3T90fVH1x9df3T90fVHNx7deHTj0Y1HNx7deHTj0Y1HNx7doO6NcDfPh9fD++HzsDysD9vD/vCjOx/d+ejOR3c+uvPRnY/ufHTnozsf3fnorkf3Rrjj8np4P3welof1YXvYHw7yfb8qfnT3o7sf3f3o7kf3vl/Fv//xD//77//lT3//X//8j//rD3/zf37+87//2z/9w7/+6Z//qf7zX/+//9mf+a//8qc///lP/+Pv/ue//PM//ON/+7d/+ce/+/M//8P3uT+M+p+//bG8/vjj/vyXP/7h51v422N/FPvh831G9I8/f3f//NfPD/m3P57nH3+8tp//+p6/v/0xUf/444h+/zm/r/vpR37+/v4vP5qzT/4Zf/zxZwxQJ9v5o5/+6p9JzR9/Ji791T8Dl5//zK9e31fnd7L+KKv//z9/9/188b//+7//l3///wE=","file_map":{"2":{"source":"use crate::cmp::Eq;\n\nunconstrained fn __get_shuffle_indices<T, let N: u32>(lhs: [T; N], rhs: [T; N]) -> [u32; N]\nwhere\n    T: Eq,\n{\n    let mut shuffle_indices: [u32; N] = [0; N];\n\n    let mut shuffle_mask: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut found = false;\n        for j in 0..N {\n            if ((shuffle_mask[j] == false) & (!found)) {\n                if (lhs[i] == rhs[j]) {\n                    found = true;\n                    shuffle_indices[i] = j;\n                    shuffle_mask[j] = true;\n                }\n            }\n            if (found) {\n                continue;\n            }\n        }\n        assert(found == true, \"check_shuffle, lhs and rhs arrays do not contain equivalent values\");\n    }\n\n    shuffle_indices\n}\n\nunconstrained fn __get_index<let N: u32>(indices: [u32; N], idx: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..N {\n        if (indices[i] == idx) {\n            result = i;\n            break;\n        }\n    }\n    result\n}\n\npub(crate) fn check_shuffle<T, let N: u32>(lhs: [T; N], rhs: [T; N])\nwhere\n    T: Eq,\n{\n    // Safety: shuffle_indices is ensured to be a permutation of 0..N, and then\n    // shuffle_indices is ensured to map lhs to rhs: assert(lhs[i] == rhs[shuffle_indices[i]]), for all i in 0..N\n    unsafe {\n        let shuffle_indices = __get_shuffle_indices(lhs, rhs);\n\n        for i in 0..N {\n            let idx = __get_index(shuffle_indices, i);\n            assert_eq(shuffle_indices[idx], i);\n        }\n        for i in 0..N {\n            let idx = shuffle_indices[i];\n            let expected = rhs[idx];\n            let result = lhs[i];\n            assert_eq(expected, result);\n        }\n    }\n}\n\nmod test {\n    use crate::cmp::Eq;\n    use super::check_shuffle;\n\n    struct CompoundStruct {\n        a: bool,\n        b: Field,\n        c: u64,\n    }\n    impl Eq for CompoundStruct {\n        fn eq(self, other: Self) -> bool {\n            (self.a == other.a) & (self.b == other.b) & (self.c == other.c)\n        }\n    }\n\n    #[test]\n    fn test_shuffle() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [2, 0, 3, 1, 4];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test]\n    fn test_shuffle_identity() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 4];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test(should_fail_with = \"check_shuffle, lhs and rhs arrays do not contain equivalent values\")]\n    fn test_shuffle_fail() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 5];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test(should_fail_with = \"check_shuffle, lhs and rhs arrays do not contain equivalent values\")]\n    fn test_shuffle_duplicates() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 3];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test]\n    fn test_shuffle_compound_struct() {\n        let lhs: [CompoundStruct; 5] = [\n            CompoundStruct { a: false, b: 0, c: 12345 },\n            CompoundStruct { a: false, b: -100, c: 54321 },\n            CompoundStruct { a: true, b: 5, c: 0xffffffffffffffff },\n            CompoundStruct { a: true, b: 9814, c: 0xeeffee0011001133 },\n            CompoundStruct { a: false, b: 0x155, c: 0 },\n        ];\n        let rhs: [CompoundStruct; 5] = [\n            CompoundStruct { a: false, b: 0x155, c: 0 },\n            CompoundStruct { a: false, b: 0, c: 12345 },\n            CompoundStruct { a: false, b: -100, c: 54321 },\n            CompoundStruct { a: true, b: 9814, c: 0xeeffee0011001133 },\n            CompoundStruct { a: true, b: 5, c: 0xffffffffffffffff },\n        ];\n        check_shuffle(lhs, rhs);\n    }\n}\n","path":"std/array/check_shuffle.nr"},"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"4":{"source":"unconstrained fn partition<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32, Env>(\n    arr: [T; N],\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n","path":"std/array/quicksort.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"50":{"source":"\nstruct Position {\n    x: u8, // column, 0-indexed\n    y: u8, // row, 0-indexed\n}\n\n/*struct Piece {\n    source_position: Position // position where piece belongs\n   // piece_type: String, // e.g., \"knight\", \"bishop\", etc.\n}*/\n\ntype Piece = u8;\n\nstruct Board<let N: u32> {\n    width: u8, // width of the board\n    height: u8, // height of the board\n    grid: BoundedVec<Option<Piece>, N>, // list of pieces on the board, indexed as x + y * width\n    empty: Position, // The position of the empty cell\n   // move_sequence: BoundedVec<Position, 1024>, // sequence of moves made\n}\n\nimpl<let N: u32> Board<N> {\n    fn get_index(self, pos: Position) -> u32 {\n        ((pos.x + pos.y * self.width) as u32)\n    }\n    \n    fn is_valid_move(self, pos: Position) -> bool {\n        let is_within_bounds = pos.x < self.width & pos.y < self.height;\n        //let is_not_empty = self.grid.get(self.get_index(&pos)).is_some();\n        \n        let is_x_adjacent = (self.empty.y == pos.y) & ((self.empty.x == pos.x + 1) | (self.empty.x + 1 == pos.x));\n        let is_y_adjacent = (self.empty.x == pos.x) & ((self.empty.y == pos.y + 1) | (self.empty.y + 1 == pos.y));\n        let is_adjacent = is_x_adjacent | is_y_adjacent;\n        \n        is_within_bounds & is_adjacent\n    }\n\n    fn make_move(&mut self, pos: Position) -> bool {\n        let mut valid = false;\n        if self.is_valid_move(pos) {\n            // Find the index of the piece to move\n            let piece_index = self.get_index(pos);\n            // Calculate the index of the empty position\n            let empty_index = self.get_index(self.empty);\n\n            // Swap the piece with the empty position\n            let tmp = self.grid.get(piece_index);\n            self.grid.set(piece_index, Option::none());\n            self.grid.set(empty_index, tmp);\n\n            // Update the empty position\n            self.empty = pos;\n\n            // Record the move\n           // self.move_sequence.push(pos);\n            valid = true;\n        }\n        valid\n    }\n\n    fn check_win_condition(self) -> bool {\n        let mut won = true;\n        // Check if the pieces are in the correct order\n        for i in 0..N {\n            let index = i as u8;\n            let piece:Option<Piece> = self.grid.get(i);\n            if piece.is_some() {\n                if piece.unwrap() != index {\n                    won = false;\n                }\n            }\n        }\n        won\n    }\n\n}\n\n\n\n\n//unconstrained fn \nglobal MAX_MOVES: u32 = 64;\n\nfn main(\n    move_count : pub u32,\n    init_grid: pub [u8; 16], // A permutation of numbers 0-15 representing the initial grid, 1-indexed, with 0 as the empty space\n    move_array: [Position; MAX_MOVES] // A sequence of moves, represented as positions to swap with the empty space\n) {\n\n    //assert(move_count == move_sequence.len() as u16, \"move count doesnt match move sequence\");\n    //check that move_count is within bounds\n    assert(move_count <= MAX_MOVES, \"move_count exceeds maximum allowed moves\");\n    \n    // Check that init_grid is a valid permutation of 0..15\n    let sorted = init_grid.sort();\n    for i in 0..16 {\n        assert(sorted[i] == i as u8, \"init_grid must be a permutation of 0..15\");\n    }\n\n    // Find empty position and transform init_grid to 0-indexed Options\n    let mut empty_index: u32 = 0;\n    let mut grid: BoundedVec<Option<Piece>, 16> = BoundedVec::new();\n    for i in 0..16 {\n        if init_grid[i] == 0u8 {\n            empty_index = i;\n            grid.push(Option::none());\n        } else {\n            let piece:Piece = init_grid[i] - 1;\n            grid.push(Option::some(piece));\n        }\n    }\n\n\n    let mut board = Board {\n        width: 4,\n        height: 4,\n        empty: Position{x: (empty_index % 4) as u8, y: (empty_index / 4) as u8 },\n        grid\n    };\n\n    // Check that the sequence of moves is valid and apply them\n    for i in 0..MAX_MOVES {\n        if i < move_count {\n            let pos = move_array[i as u32];\n            assert(board.make_move(pos), \"Invalid move\");\n        }\n    }\n\n    // Check if the board is in a winning state\n    assert(board.check_win_condition(), \"Move sequence isn't winning\");\n\n}\n\n\n#[test]\nfn test_main() {\n   // let mut ms = BoundedVec::new();\n   // ms.push(Position{x: 3, y: 3});\n    let mut array: [Position; MAX_MOVES] = [Position{x: 0, y: 0}; MAX_MOVES];\n    array[0] = Position{x: 3, y: 3};\n    main(1,\n    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,15],\n    array);\n\n    // Uncomment to make test fail\n    // main(1, 1);\n}\n\n//3\n","path":"/home/porksausage/vsprojects/fifteenweb2/circuit/src/main.nr"}},"names":["main"],"brillig_names":["quicksort","__get_shuffle_indices","__get_index","directive_integer_quotient","directive_invert"]}