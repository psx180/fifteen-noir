{"noir_version":"1.0.0-beta.9+6abff2f16e1c1314ba30708d1cf032a536de3d19","hash":"8875874701513761501","abi":{"parameters":[{"name":"move_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"init_grid","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"move_array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"Position","fields":[{"name":"x","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"y","type":{"kind":"integer","sign":"unsigned","width":8}}]}},"visibility":"private"}],"return_type":null,"error_types":{"2056779005453440704":{"error_kind":"string","string":"init_grid must be a permutation of 0..15"},"2763232959425933230":{"error_kind":"string","string":"Attempted to write past end of BoundedVec"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3585749724882332783":{"error_kind":"string","string":"move_count exceeds maximum allowed moves"},"4881232171340953631":{"error_kind":"string","string":"Move sequence isn't winning"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14762772751442043855":{"error_kind":"string","string":"Invalid move"},"15544221083219072719":{"error_kind":"string","string":"check_shuffle, lhs and rhs arrays do not contain equivalent values"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17679955115386040593":{"error_kind":"string","string":"Array has not been sorted correctly according to `ordering`."},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"2":{"source":"use crate::cmp::Eq;\n\nunconstrained fn __get_shuffle_indices<T, let N: u32>(lhs: [T; N], rhs: [T; N]) -> [u32; N]\nwhere\n    T: Eq,\n{\n    let mut shuffle_indices: [u32; N] = [0; N];\n\n    let mut shuffle_mask: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut found = false;\n        for j in 0..N {\n            if ((shuffle_mask[j] == false) & (!found)) {\n                if (lhs[i] == rhs[j]) {\n                    found = true;\n                    shuffle_indices[i] = j;\n                    shuffle_mask[j] = true;\n                }\n            }\n            if (found) {\n                continue;\n            }\n        }\n        assert(found == true, \"check_shuffle, lhs and rhs arrays do not contain equivalent values\");\n    }\n\n    shuffle_indices\n}\n\nunconstrained fn __get_index<let N: u32>(indices: [u32; N], idx: u32) -> u32 {\n    let mut result = 0;\n    for i in 0..N {\n        if (indices[i] == idx) {\n            result = i;\n            break;\n        }\n    }\n    result\n}\n\npub(crate) fn check_shuffle<T, let N: u32>(lhs: [T; N], rhs: [T; N])\nwhere\n    T: Eq,\n{\n    // Safety: shuffle_indices is ensured to be a permutation of 0..N, and then\n    // shuffle_indices is ensured to map lhs to rhs: assert(lhs[i] == rhs[shuffle_indices[i]]), for all i in 0..N\n    unsafe {\n        let shuffle_indices = __get_shuffle_indices(lhs, rhs);\n\n        for i in 0..N {\n            let idx = __get_index(shuffle_indices, i);\n            assert_eq(shuffle_indices[idx], i);\n        }\n        for i in 0..N {\n            let idx = shuffle_indices[i];\n            let expected = rhs[idx];\n            let result = lhs[i];\n            assert_eq(expected, result);\n        }\n    }\n}\n\nmod test {\n    use crate::cmp::Eq;\n    use super::check_shuffle;\n\n    struct CompoundStruct {\n        a: bool,\n        b: Field,\n        c: u64,\n    }\n    impl Eq for CompoundStruct {\n        fn eq(self, other: Self) -> bool {\n            (self.a == other.a) & (self.b == other.b) & (self.c == other.c)\n        }\n    }\n\n    #[test]\n    fn test_shuffle() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [2, 0, 3, 1, 4];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test]\n    fn test_shuffle_identity() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 4];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test(should_fail_with = \"check_shuffle, lhs and rhs arrays do not contain equivalent values\")]\n    fn test_shuffle_fail() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 5];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test(should_fail_with = \"check_shuffle, lhs and rhs arrays do not contain equivalent values\")]\n    fn test_shuffle_duplicates() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 3];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test]\n    fn test_shuffle_compound_struct() {\n        let lhs: [CompoundStruct; 5] = [\n            CompoundStruct { a: false, b: 0, c: 12345 },\n            CompoundStruct { a: false, b: -100, c: 54321 },\n            CompoundStruct { a: true, b: 5, c: 0xffffffffffffffff },\n            CompoundStruct { a: true, b: 9814, c: 0xeeffee0011001133 },\n            CompoundStruct { a: false, b: 0x155, c: 0 },\n        ];\n        let rhs: [CompoundStruct; 5] = [\n            CompoundStruct { a: false, b: 0x155, c: 0 },\n            CompoundStruct { a: false, b: 0, c: 12345 },\n            CompoundStruct { a: false, b: -100, c: 54321 },\n            CompoundStruct { a: true, b: 9814, c: 0xeeffee0011001133 },\n            CompoundStruct { a: true, b: 5, c: 0xffffffffffffffff },\n        ];\n        check_shuffle(lhs, rhs);\n    }\n}\n","path":"std/array/check_shuffle.nr"},"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"4":{"source":"unconstrained fn partition<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            let temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i += 1;\n        }\n    }\n\n    let temp = arr[i];\n    arr[i] = arr[pivot];\n    arr[pivot] = temp;\n    i\n}\n\nunconstrained fn quicksort_loop<T, let N: u32, Env>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) {\n    let mut stack: [(u32, u32)] = &[(low, high)];\n    // TODO(https://github.com/noir-lang/noir_sort/issues/22): use 'loop' once it's stabilized\n    for _ in 0..2 * N {\n        if stack.len() == 0 {\n            break;\n        }\n\n        let (new_stack, (new_low, new_high)) = stack.pop_back();\n        stack = new_stack;\n\n        if new_high < new_low + 1 {\n            continue;\n        }\n\n        let pivot_index = partition(arr, new_low, new_high, sortfn);\n        stack = stack.push_back((pivot_index + 1, new_high));\n        if 0 < pivot_index {\n            stack = stack.push_back((new_low, pivot_index - 1));\n        }\n    }\n}\n\npub unconstrained fn quicksort<T, let N: u32, Env>(\n    arr: [T; N],\n    sortfn: unconstrained fn[Env](T, T) -> bool,\n) -> [T; N] {\n    let mut arr: [T; N] = arr;\n    if arr.len() > 1 {\n        quicksort_loop(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n","path":"std/array/quicksort.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"50":{"source":"\nstruct Position {\n    x: u8, // column, 0-indexed\n    y: u8, // row, 0-indexed\n}\n\n/*struct Piece {\n    source_position: Position // position where piece belongs\n   // piece_type: String, // e.g., \"knight\", \"bishop\", etc.\n}*/\n\ntype Piece = u8;\n\nstruct Board<let N: u32> {\n    width: u8, // width of the board\n    height: u8, // height of the board\n    grid: BoundedVec<Option<Piece>, N>, // list of pieces on the board, indexed as x + y * width\n    empty: Position, // The position of the empty cell\n   // move_sequence: BoundedVec<Position, 1024>, // sequence of moves made\n}\n\nimpl<let N: u32> Board<N> {\n    fn get_index(self, pos: Position) -> u32 {\n        ((pos.x + pos.y * self.width) as u32)\n    }\n    \n    fn is_valid_move(self, pos: Position) -> bool {\n        let is_within_bounds = pos.x < self.width & pos.y < self.height;\n        //let is_not_empty = self.grid.get(self.get_index(&pos)).is_some();\n        \n        let is_x_adjacent = (self.empty.y == pos.y) & ((self.empty.x == pos.x + 1) | (self.empty.x + 1 == pos.x));\n        let is_y_adjacent = (self.empty.x == pos.x) & ((self.empty.y == pos.y + 1) | (self.empty.y + 1 == pos.y));\n        let is_adjacent = is_x_adjacent | is_y_adjacent;\n        \n        is_within_bounds & is_adjacent\n    }\n\n    fn make_move(&mut self, pos: Position) -> bool {\n        let mut valid = false;\n        if self.is_valid_move(pos) {\n            // Find the index of the piece to move\n            let piece_index = self.get_index(pos);\n            // Calculate the index of the empty position\n            let empty_index = self.get_index(self.empty);\n\n            // Swap the piece with the empty position\n            let tmp = self.grid.get(piece_index);\n            self.grid.set(piece_index, Option::none());\n            self.grid.set(empty_index, tmp);\n\n            // Update the empty position\n            self.empty = pos;\n\n            // Record the move\n           // self.move_sequence.push(pos);\n            valid = true;\n        }\n        valid\n    }\n\n    fn check_win_condition(self) -> bool {\n        let mut won = true;\n        // Check if the pieces are in the correct order\n        for i in 0..N {\n            let index = i as u8;\n            let piece:Option<Piece> = self.grid.get(i);\n            if piece.is_some() {\n                if piece.unwrap() != index {\n                    won = false;\n                }\n            }\n        }\n        won\n    }\n\n}\n\n\n\n\n//unconstrained fn \nglobal MAX_MOVES: u32 = 16;\n\nfn main(\n    move_count : pub u32,\n    init_grid: pub [u8; 16], // A permutation of numbers 0-15 representing the initial grid, 1-indexed, with 0 as the empty space\n    move_array: [Position; MAX_MOVES] // A sequence of moves, represented as positions to swap with the empty space\n) {\n\n    //assert(move_count == move_sequence.len() as u16, \"move count doesnt match move sequence\");\n    //check that move_count is within bounds\n    assert(move_count <= MAX_MOVES, \"move_count exceeds maximum allowed moves\");\n    \n    // Check that init_grid is a valid permutation of 0..15\n    let sorted = init_grid.sort();\n    for i in 0..16 {\n        assert(sorted[i] == i as u8, \"init_grid must be a permutation of 0..15\");\n    }\n\n    // Find empty position and transform init_grid to 0-indexed Options\n    let mut empty_index: u32 = 0;\n    let mut grid: BoundedVec<Option<Piece>, 16> = BoundedVec::new();\n    for i in 0..16 {\n        if init_grid[i] == 0u8 {\n            empty_index = i;\n            grid.push(Option::none());\n        } else {\n            let piece:Piece = init_grid[i] - 1;\n            grid.push(Option::some(piece));\n        }\n    }\n\n\n    let mut board = Board {\n        width: 4,\n        height: 4,\n        empty: Position{x: (empty_index % 4) as u8, y: (empty_index / 4) as u8 },\n        grid\n    };\n\n    // Check that the sequence of moves is valid and apply them\n    for i in 0..MAX_MOVES {\n        if i < move_count {\n            let pos = move_array[i as u32];\n            assert(board.make_move(pos), \"Invalid move\");\n        }\n    }\n\n    // Check if the board is in a winning state\n    assert(board.check_win_condition(), \"Move sequence isn't winning\");\n\n}\n\n\n#[test]\nfn test_main() {\n   // let mut ms = BoundedVec::new();\n   // ms.push(Position{x: 3, y: 3});\n    let mut array: [Position; MAX_MOVES] = [Position{x: 0, y: 0}; MAX_MOVES];\n    array[0] = Position{x: 3, y: 3};\n    main(1,\n    [1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,15],\n    array);\n\n    // Uncomment to make test fail\n    // main(1, 1);\n}\n\n//3\n","path":"/home/porksausage/vsprojects/fifteenweb2/circuit/src/main.nr"}},"names":["main"],"brillig_names":["quicksort","__get_shuffle_indices","__get_index","directive_integer_quotient","directive_invert"]}